# Zsh Workshop

## 介绍

　　所有用户与 UNIX 系统交互的方式都是他们的SHELL。SHELL 为用户运行程序，从运行中的进程导入或导出数据。它给了用户一个完成 UNIX 工作的环境。

　　如果配置正确，UNIX SHELL 会让系统使用起来更加方便和简单。如果你的 SHELL 没有按照你的喜好来配置，使用它可能会导致效率大大降低，令人头疼，并且有时候会产生有害的、意想不到的效果。

　　**本书并不是试图让你使用zsh。**如果你已经使用一个 SHELL 15年了，你需要一个更好地理由将它换为 zsh。（也许本书会为你提供一点点）

　　本书的目的是**如何使用zsh让你的 UNIX 体验更加高效和愉快**。我会告诉你很多操作和配置zsh的方法。
　　
　　本书主要分为三个部分：
　　- 配置————让 zsh 的行为完全符合你希望的方式。
　　- 编程————利用一切可能充分利用脚本和函数。
　　- 技巧————大量的操作技巧和方法。

### 为什么选择 zsh？

　　Zsh 可以说是**最强大的和可配置的** UNIX SHELL。如果有的话，只有极少的事情其他 SHELL 可以做而 zsh 不能做。这也是为什么本书推荐 zsh 的原因。

　　简而言之，它可以让你用更少的时间完成更多的工作。

#### 特色

　　下面是一些 zsh 的特色。

<TABLE>
<TR COLSPAN=3>
<TD>别名
<TD>任务控制
<TD>函数

<TR>
<TD>简单灵活的 I/O 控制
<TD>目录堆栈
<TD>命令历史

<TR>
<TD>命令行编辑(vi, emacs, 自定义)
<TD>完全键盘映射
<TD>查找用户名

<TR>
<TD>登录/注销控制
<TD>高级文件名补全
<TD>主机名补全

<TR>
<TD>用户名补全
<TD>历史补全
<TD>完全编程补全

<TR>
<TD>SHELL受限模式
<TD>协同进程
<TD>内置算法评估

<TR>
<TD>隐藏符号链接
<TD>本地变量
<TD>定时命令

<TR>
<TD>简单可扩展提示符
<TD>拼写纠正
<TD>进程替换

<TR>
<TD>底层 sh 语法
<TD>处理大参数列表
<TD>避免用户setup file

<TR>
<TD>列出变量
<TD>全局别名
<TD>信号陷阱处理
</TABLE>

### 本书不包括

Zsh 的优点并不能简单的描述完全。以下是并不包含的内容，如果你对这些感兴趣，你可以自己去研究：

- 扩展参数标志

有很多方法可以获得 zsh 的扩展参数。比如

```shell
man zshexpn
```

- 命令行编辑

Zsh 的命令行编辑完全支持编程和绑定。你可以写自己的函数来控制光标和命令行的内容。zsh 还支持 **emacs**，**vi** 命令。执行以下命令了解详细信息：

```shell
man zshzle
```

- 动态加载模块

你可以编写自己的函数并实时的添加它。Zsh 中的许多东西都是作为模块实现的，例如完成控制。执行如下命令了解详细信息：

```shell
man zshmodules
```

- 构造语法

很遗憾我没有时间完成控制编程这部分。 例如 if for which case 等等。也许这部分会以后添加。

## 配置 ZSH

### 初始文件

像许多的 SHELL 一样，zsh 处理许多系统和用户的初始配置文件。了解这些文件的读取顺序和导致文件被忽略的情况非常重要。否则，你的命令或者起始配置文件可能不会被 zsh 执行。

#### 启动过程

在下面的描述中，zsh 默认会查找用户家目录下的配置文件。如果你希望它查找其他目录的配置文件，将参数 ZDOTDIR 设置为你想要的目录。

当 zsh 启动时，以下文件会被读取：

1. 读取 **/etc/zshenv**

如果在 **/etc/zshenv** 中未设置 **RCS** 选项，所有其他文件都会被跳过。

2. 读取 **~/.zshenv**
3. 如果 SHELL 为 login shell，读取 **/etc/zprofile**,然后是**~/.zprofile**
4. 如果 SHELL 为交互 SHELL ，读取 **/etc/zshrc**，然后是**~/.zshrc**
5. 最后，如果为 login shell，读取 **/etc/zlogin**，然后是 **~/.zlogin**
6. 当用户注销时，读取 **/etc/zlogout**，然后是 **~/.zlogout**

#### 术语解释

- **login shell**：登录 shell 一般在登录时产生，即当你使用 /bin/login 或者其他接入程序时，例如 SSH、rlogin、telnet等。例如：

```shell
ssh HOST_NAME SOME_COMMAND
```

即启动一个登录 shell

- **交互 SHELL ：交互 SHELL 是一个会显示提示并允许用户使用命令交互的 SHELL。

#### 注意

除了 /etc 还有**另一个**目录可以作为全局配置读取。可以再安装时确定。

### 通过选项配置 zsh

Zsh 有超过**一百多**个选项来控制 zsh 各方面的行为。每个选项都有一个名字，可以被打开或者关闭。

Zsh 提供了一些方法来打开或者关闭这些选项。最简单的可能是下面这个：

```shell
setopt OPTION_NAME   # 打开选项
unsetopt OPTION_NAME # 关闭选项
```

Zsh 的选项是大小写不敏感的，并且下划线会被忽略。这样可以使选项的名字简答易读。按照惯例一般全部大写。

任何一个选项都可以在前面加上 'NO' 来关闭。例如，如果你想关闭蜂鸣声，可以使用如下命令：

```shell
setopt NO_BEEP
```

有一些选项其实是其他选项的替代名称。这样有助于向后兼容 BASH 或者 KSH。（详情见手册）

### 提示符

Zsh 的提示符是**完全**可配置的。事实上，zsh 的提示符会获得它们自己的扩展类型。（如果你想在其他字符串上使用提示扩展，只需要 **-P** 参数指向 zsh 的内建函数 **print**）

Zsh 的**主要**提示符串包含在 SHELL 变量的 **PROMPT**中。这个变量也被称为 **PS1**。(它们是完全相同的，设置一个会影响另一个)

在 zsh 实际显示它们之前，提示符首先进行参数扩展，命令替换和算法扩展。（只有当 **PROMPT_SUBST** 选项打开时）

- 定制提示符

有些时候，每个人都想要定制自己独特的提示符。在 zsh 中有超过40个特殊的转移序列，允许你控制提示符中需要显示的信息。

像大多数 SHELL 一样，zsh 允许你在提示符中显示各种信息。当前时间、日期、主机信息或者当前目录等等。

Zsh 可以更进一步。它允许你截断你的提示，以便于它只占用命令行上一定的空间。它还为每个可显示的信息提供了许多不同的选项。它可以通过 **strftime(3)** 函数打印时间和日期。Zsh 在提示符中还支持 **“条件表示”**。这表示 zsh 可以根据特定的条件显示不同的提示信息。

在下面几个部分中，我们将讨论**所有可以使用的工具**来自定义你的提示符。

#### 在提示符中显示转移序列

通过特殊的**转义字符**定制你的提示符是非常简单但是重要的方法，有许多的**转义字符**代表不同的信息。大部分转移字符由符号**'%'**开始。然后，在 **PROMPT** 变量内，每一个转移字符都会由它们代表的信息代替。

一些转移字符可以使用可选的**整型参数**，它紧跟在**'%'**符号**之后**并在转移字符**之前**。

**转移序列和描述**

左边是转移字符，右边是它们代表的信息。

**注意**：新的转义字符可能会在以后添加。参考以下手册获取最新列表：

```shell
man zshmisc
```
- 字符

| 转义字符 | 代表信息 |
| -------- | -------- |
| %%       | %        |
| %)       | )        |

- 目录

| 转义字符 | 代表信息                              |
| -------- | ------------------------------------- |
| %d       | 当前目录-%PWD                         |
| %/       | 和%d相同                              |
| %~       | %PWD, 如果为%HOME，显示~              |
| %c       | PWD尾部组件。若想添加n个组件，使用%nc |
| %.       | 和%c相同                              |
| %C       | 与%c，%.相似，除了~不显示目录名称     |

- 主机名信息

| 转义字符 | 代表信息                               |
| -------- | -------------------------------------- |
| %M       | 全部主机名                             |
| %m       | 主机名到第一个'.' 可以使用%nm代表第n个 |

- 当前时间信息

| 转义字符 | 代表信息                      |
| -------- | ----------------------------- |
| %t       | 当前时间，12小时制，AM/PM格式 |
| %@       | 与%t相同                      |
| %T       | 当前时间，24小时制            |
| %\*      | 当前时间，24小时制，包含秒    |

- 当前日期

| 转义字符   | 代表信息                       |
| ---------- | ------------------------------ |
| %w         | 当前日期，day-dd 格式          |
| %W         | 当前日期，mm/dd/yy格式         |
| %D         | 当前日期，yy-mm-dd格式         |
| %D{string} | 字符串使用strftime函数格式化。 |

- 杂项

| 转义字符 | 代表信息                                |
| -------- | --------------------------------------- |
| %h       | 当前历史时间编号                        |
| %!       | 与%h相同                                |
| %L       | %SHLVL 的值                             |
| %n       | 等于 %USERNAME                          |
| %l       | 用户登录的行（tty）                     |
| %?       | 最后一个命令的返回码                    |
| %\_      | if for while 等等                       |
| %E       | 清除至行尾                              |
| %#       | 如果shell使用权限运行就是'#'，否则是‘%‘ |
| %v       | psvar数组参数的第一个元素的值           |

#### 提示符中的条件表示

在 zsh 提示符中，条件表达式是一个简单的取决于条件的表达式。你可以在你的提示符中根据条件使用它们来显示有用的信息。

要在你的提示符中使用条件表达式，使用以下的转义字符和语法：

> %(X.true-text.false-text)

以下内容直接取自手册。

> 指定一个三元表达式。跟在 X 后的符号是任意的；同样的符号用于区分结果为'真'的文本和结果为'假'的文本。这个分隔符不能出现在“true-text”中，除非作为转移字符。‘）’可能会出现在“false-text”中作为‘%）’。
>
> “true-text”和“false-text”可以任意的嵌套上一节中的转移字符，包括一个新的三元表达式。
>
> 左括号的前面可以添加一个正整数n，默认为0。‘X’可以取以下符号：
>
> | 符号  | 功能                                |
> | ----- | ----------------------------------- |
> | c . ~ | 若当前路径至少有n个前缀替换，则为真 |
> | / C   | 若当前绝对路径至少有n个元素，则为真 |
> | t     | 若当前分钟数等于n，则为真           |
> | T     | 若当前小时数等于n，则为真           |
> | d     | 若当前日等于n，则为真               |
> | D     | 若当前月等于n，则为真（一月为0）    |
> | w     | 若当前星期等于n，则为真（周一为0）  |
> | ？    | 若上一个命令的退出状态为n，则为真   |
> | #     | 若当前进程的有效uid等于n，则为真    |
> | g     | 若当前有效gid等于n，则为真          |
> | L     | 若参数SHLVL至少为n，则为真          |
> | S     | 若参数SECONDS至少为n，则为真        |
> | v     | 若psvar数组至少有n个元素，则为真    |
> | \_    | 若至少有n个构造器启动，则为真       |
> | ！    | 若SHELL使用特权运行，则为真         |

#### 格式化提示

你可以截断你的提示符以使用固定个数的空间。“man zshmisc” 查看详细信息，并查看PROMPT EXPANSION部分。

- 额外的格式转义

有一些额外的‘%’转义序列控制着 zsh 显示提示符的格式：

| 转义符 | 功能           |
| ------ | -------------- |
| %U     | 打开下划线模式 |
| %u     | 关闭下划线模式 |
| %B     | 打开粗体模式   |
| %b     | 关闭粗体模式   |
| %S     | 打开突出模式   |
| %s     | 关闭突出模式   |

> %{...%}
>
> 包含一个字符串代表转移序列。大括号内的字符串不应该改变光标位置。大括号可以嵌套，这可以用来在你的提示符中显示颜色。（见下文）

- 快速注释

如果你想在你的提示符中使用当前历史事件编号而不需要%转义序列，确保打开**PROMPT_BANG**选项。

这允许你在提示符中使用**‘  ！’**作为当前历史事件编号。如果你想要**‘  ！’**显示在你的提示符中，使用**‘  ！！’**。

### 查看其他用户

Zsh 为查看特定用户的登入和登出提供一种有效的方法，用户来自一个确定的主机或者一个确定的tty（终端）或者pty（虚拟终端）等等。

首先，我们看一下一个事件是什么，并举一个例子。然后，我们学习怎么将一个事件提供给 zsh 和怎样获取有用的zsh 报告。下一页，我们将学习怎么样自定义这些报告的外观。

#### 事件

对于本节来说，**事件**就是zsh 运行的主机上的任何登录和注销活动。

一个事件包含以下内容：

- 登录或注销的用户
- 用户连接的主机
- 用户连接的终端（tty）

要寻找特定用户相关的事件，只需要在事件说明中使用他们的用户名。

要寻找特定主机的事件，使用 “@” 后跟随主机名。

要寻找特定终端的事件，使用 “%” 后跟随终端名称。

这些元素中的任何一个或所有都可以用来指定事件。Zsh 会返回所有匹配指定元素的事件。

**实例**

匹配与用户 schrof 相关的事件的条目：

> schrof

匹配主机 nebcorp.com 并在虚拟终端 pts/19 的所有条目：

> @nebcorp.com%pts/19

匹配控制台上 root 用户的所有条目：

> root%console

#### 告诉 zsh 查找事件

你需要将 zsh 应该监视的事件列表放在 **watch** 或者 **WATCH** 变量中。这可以通过命令行完成，但是通常你更想设置一个同时设置另一个。如果这个 shell 被 sh 或者 ksh **调用**，你**必须**使用大写的 **WATCH** 变量。

正常情况下，你会分配给 watch 变量一个数组。 然而我们这里有两个特例：

1. 监视这个系统的**所有**时间，你可以简单的赋值 all 给 watch ：

> watch=all

2. 监视**除了**你意外的所有时间，你可以赋值 notme 给 watch ：

> watch=notme

否则，你需要分配一个事件列表：

> watch=(event1 event2 ... eventN)

然后 zsh 会报告所有配置你的设置的事件。

#### 获取报告

为 LOGCHECK 变量设置某个整数 n 会使 zsh 每 n 秒反馈一次报告（默认为60秒）。你可以随时通过运行 log 命令报告当前登录的受 watch 变量监视的用户。

下一节包含有关配置报告外观的详细信息。

#### 格式化登录、注销监视器

你可以随意定制事件报告的显示方式。通过在参数 WATCHFMT 中配置一个特殊的格式字符串。像各种提示参数一样，有许多有用的转义序列。。。

以下内容引用自手册：
| 转义序列 | 内容                     |
| -------- | ------------------------ |
| %n       | 用户的名称               |
| %a       | 时间的行为（登录、注销） |
| %l       | 使用的终端               |
| %M       | 全部的主机名             |
| %m       | 第一部分主机名。         |
| %S（%s） | 打开（关闭）突出模式     |
| %U（%u） | 打开（关闭）下划线模式   |
| %B（%b） | 打开关闭粗体模式         |
| %t 或 %@ | 时间，12小时制，am/pm    |
| %T       | 时间，24小时制           |
| %w       | 日期，day-dd格式         |
| %W       | 日期，mm/dd/yy格式       |
| %D       | 日期，yy-mm-dd格式       |

> %(X : true-text : false-text)

上面这个三元式和条件提示符非常相似。如果X为真，则显示 true-text，如果X为假，则显示 false-text。

“X” 可以指定为以下字符：‘l’，‘n’，‘m’，‘M’ 或 ‘a’。如果这些转义字符匹配到非零值，则为真。‘a’ 是一个特殊情况。如果是登录事件，则为真；如果为注销事件，则为假。

一些**提示**：

- 这些三元式可以**嵌套**
- true-text 和 false-text 可以为空
- 两个分隔符不可以**省略**

## 易用性

### 别名

#### 什么是别名

在大多数 SHELL 中，别名是用户**自定义**的命令的替代名称。它们经常被用来缩短命令长度，或者代表更常用的命令。例如，某用户可以定义 myprocs 来运行 ps -fu $LOGNAME。

Zsh 由以下方式定义别名。它有一个非常灵活和强大的系统来定义、使用和操作别名。

#### 别名是怎么工作的？

检查输入中的每个标记以确定是否为它定义了别名。如果定义了别名，这段字符会在以下情况被它定义的命令替换：

- 这个别名在命令的某个位置
- 别名是全局性
- 该行的上一个单词是一个以空格结尾的别名

#### 使用别名

Zsh 内建函数 alias 的语法如下

> alias [ -gmrL ]  \[name [=value] ...]

-r 参数表示 alias 命令为**常规模式**。 -g 参数表示 alias 为**全局模式**。若不加 -r 或者 -g 则对这两种类型都有效。

如果只写某个值，zsh 将打印名称和它的定义。若没有任何参数，alias 打印所有定义的 alias。

使用 -L 参数，别名的会剪切复制到你的启动脚本中。

要定义一个或多个别名，只需要输入：

> alias **name1=value1 name2=value2 ... nameN=valueN**

对于每个相应的名称，zsh 将使用该值定义一个别名。

#### 全局别名

即使你的别名不再命令中的第一个单词，zsh也允许你使用别名。这种别名称为 **全局别名**。

例如，假设你对你的 .procmailrc 文件做了许多工作。你运行了许多工具，例如 emacs，cp，less 等等。你不想为你的每个命令定义一个别名。这将会执行以下命令：

```shell
alias wprc="wc -l ~/.procmailrc"
alias cprc="cp ~/.procmailrc ~/.procmailrc.safe"
alias eprc="emacs ~/.procmailrc"
```

相反，你可以使用文件的全局别名。要定义一个全局别名，使用 -g 参数。

```shell
alias -g prc=~/.procmailrc
```

现在你可以简单的在任何地方查看你的 .procmailrc 文件：

```shell
lyric > emacs -nw prc
```

看[这里](https://www-s.acm.illinois.edu/workshops/zsh/related/messy_global.html)，如果你对一个不是那么强大的别名感兴趣。

#### 列出匹配模式的别名

你可以让 zsh 打印出那些符合给定模式的别名，而不是所有的。你可以添加参数 -m 到 alias 命令中。pattern 与文件名生成模式完全相同。事实上，你需要在 pattern 两边增加单引号以防止 zsh 将它当做文件名匹配模式。

#### 禁用和删除别名

你可以使用以下命令删除别名foo ： unalias foo

你也可以**临时**禁用别名foo ： disable -a foo

也可以重新激活它： enable -a foo

最后，你可能会有一个别名例如 ftp ，它实际上运行了一个不同的程序。如果你想要使用真正的 ftp 程序，在命令中使用 “=ftp” 或者 “\ftp”。

### cd：完整的故事

cd 用于更改你当前的工作目录。他可以通过各种方式使用。（你也可以使用cddir ，它们是完全相同的）

#### 第一种形式

对于几乎所有UNIX系统的 shell，cd 基本的用法如下：
| 输入       | 作用                          |
| ---------- | ----------------------------- |
| cd         | 切换到家目录，${HOME}         |
| cd NEW_DIR | 切换到某个目录                |
| cd -       | 切换到你刚才的目录，${OLDPWN} |

Zsh 为 cd 添加了一些有用的**函数**。

第一，如果 zsh 没有在当前目录找到 NEW_DIR（并且NEW_DIR不是一个绝对路径），zsh 会查询 shell 变量 **cdpath**。它会在 cdpath 的每个目录中查找子目录 NEW_DIR ， 如果找到NEW_DIR，就会转向那个目录。

此外，如果你喜欢，你可以将一个目录的完整路径存储在一个 shell 变量中。然后，你可以输入 cd VAR 进入包含在变量 VAR 中的路径。例如：

```shell
  lyric >  XDIR=/usr/lib/X11
  lyric >  cd XDIR
  ~XDIR
  lyric >  pwd
  /usr/lib/X11
```

为什么这个有用呢？为什么不直接输入$XDIR？原因是你可以获得其他的好处，本质上讲，这意味着这个目录可以迅速扩展和各种内建中得到特殊处理。

#### 第二种形式

第二种形式非常方便！输入：

```shell
cd OLD NEW
```

然后 zsh 使用NEW替换当前目录所有出现的OLD，并那个目录。

一个例子：

```shell
  lyric > pwd
  /usr/local/encap/fvwm-2.2/libexec/fvwm/2.2
  lyric > cd 2.2 2.0.46
  /usr/local/encap/fvwm-2.0.46/libexec/fvwm/2.0.46
  lyric > 
```

#### 第三种形式

第三种形式是从目录栈中抽取一个条目，并切换到该目录。（n 为一个整数）

```shell
cd +n
cd -n
```

要查看目录栈，输入

> dirs -v

给入参数 “+n” 会提取目录栈的第n个条目，从左边（上边）开始数。使用 “-n” 从右边（下边）开始数。

如果你想切换 ‘+’ 和 ‘-’ 的含义，请打开选项 PUSHD_MINUS。

#### cd 的参数

所有的 cd 形式都可以使用以下参数：
| 命令      | 功能                                 |
| --------- | ------------------------------------ |
| cd -s DIR | 如果DIR中包含链接，则不进入DIR       |
| cd -P DIR | 切换之前将所有符号链接设为真实值     |
| cd -L DIR | 遵循符号链接，忽略 CHASE_LILNKS 选项 |

**注意**： 打开选项 CHASE_LINKS 与 -P 效果相同。

### 目录栈

Zsh 有一个内置的目录栈。这个工具可以帮助你在整个 zsh 会话中管理许多不同的工作。

#### 使用方法

使用 **pushd** 命令将目录放置到目录堆栈中。使用 **popd** 将目录从堆栈中移除。可以使用 **dirs** 命令查看或者重建堆栈。

要查看堆栈的内容，只需要简单的输入以下指令（没有参数也可以但是输出不易读）：

```shell
  > dirs -v
  0       /etc/mail
  1       /var
  2       /tmp
  3       /usr/local
  4       /usr
  5       ~
  >
```

如果你要重建堆栈，使用 **dirs** 后面跟目录名称列表。zsh 会执行以下步骤：

- 删除堆栈的所有目录
- 从最右边开始将所有参数放入堆栈
- 将 $PWD 放入堆栈最上面

```shell
  > echo $PWD
  /tmp
  > dirs /usr/local/ews /usr/local /usr /var /var/log $HOME
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr/local
  3       /usr
  4       /var
  5       /var/log
  6       ~
  >
```

**popd**

popd 从堆栈中删除条目，并 cd 到最新的顶层目录。

行为

- 没有参数时，从堆栈中删除当前顶层目录项，并将cd移到新的顶层目录。 
- popd 可以带一个参数 +n 或 -n ，n是一个整数。
  - +n，会删除从顶部起第n个元素
  - -n，会删除从底部起第n个元素
- 计数从零开始
- 如果你打开选项 PUSHD_MINUS，+ 和 - 的意义会相反。

```shell
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr/local
  3       /usr
  4       /var
  5       /var/log
  6       ~
  > setopt PUSHD_MINUS
  > popd -2
  > echo $PWD
  /tmp
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr
  3       /var
  4       /var/log
  5       ~
  > popd
  > echo $PWD
  /usr/local/ews
  > dirs -v
  0       /usr/local/ews
  1       /usr
  2       /var
  3       /var/log
  4       ~
  >
```

**pushd**

pushd 修改当前目录到一个你指定的参数，并将 $OLDPWD 的内容入栈。

- 第一种形式：pushd [arg]

修改当前目录到 arg。如果 arg 没有指定，跳转到第二个元素。

```shell
  > pwd
  /etc
  > dirs -v
  0       /etc
  1       /usr/local/ews
  > pushd mail
  > dirs -v
  0       /etc/mail
  1       /etc
  2       /usr/local/ews
```

**注意**：如果选项 PUSHD_TO_HOME 打开，或者只有一个元素在堆栈内，pushd 更改当前目录到 $HOME。

如果 arg 是 “-”，pushd 修改目录到 $OLDPWD。如果 arg 在当前目录找不到，并且 arg 不包含 “/”，zsh 会查找参数 cdpath 的每一个条目。如果选项 CDABLE_VARS 打开，并且变量名 arg 存在并包含一个完整路径，会将 arg 的值作为目录。

如果选项 PUSHD_SILENT 没有打开，目录堆栈会在 pushd 命令后被打印。

- 第二种形式：pushd old new

pushd 使用 new 替换 old ， 并尝试切换到这个新的目录。（和 cd 的第二种形式相似）

- 第三种形式：pushd ｛+ | -｝n

使 pushd 通过旋转堆栈来更改当前目录。参数 n 在 popd 中已经描述。

```shell
  > setopt PUSHD_MINUS
  > dirs -v
  0       /etc/mail
  1       /usr/local
  2       /usr
  3       ~
  > pushd -2
  /usr
  > dirs -v
  0       /usr
  1       ~
  2       /etc/mail
  3       /usr/local
```

**文件名扩展和目录堆栈**

Zsh提供了一种在日常工作中快速引用目录堆栈的好方法。 以下说明直接从手册页获取： 

>  后跟一个数字的“〜”被目录堆栈中的那个位置替换。 “〜0”相当于“〜+”，“〜1”是堆栈的顶部。“〜+”后面跟着一个数字被堆栈中那个位置替换。“〜+0”等于“〜+”，“〜+1”是堆栈的顶部。“〜-”后面跟着一个数字被堆栈中从底部开始的那个位置替换。“〜-0”是堆栈的底部。选项 PUSHD_MINUS 交换 ‘+’ 和 ‘-’ 的影响。

### 大括号扩展

大括号扩展是一个方便的功能，它允许你在命令行上快速的生成项目列表。

一个这种格式的字符串 **str {xx, yy, zz} ing** 会被扩展为独立的单词 **strxxing, stryying, strzzing**。顺序从左到右。

实例：

```shell
  > ls -l array{5d,MYd,BIG}
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 array5d
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 arrayBIG
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 arrayMYd
```

如果形式为{n1..n2}，其中 n1，n2 是整数，则结果为从 n1 到 n2 的所有数字。如果任何一个数字从零开始，则所有的数字都以零为开头填充。

实例：

```shell
  > touch logfile.9908{01..31}.tmp
  > ls logfile*
  logfile.990301.tmp  logfile.990309.tmp  logfile.990317.tmp ogfile.990325.tmp
  logfile.990302.tmp  logfile.990310.tmp  logfile.990318.tmp ogfile.990326.tmp
  logfile.990303.tmp  logfile.990311.tmp  logfile.990319.tmp ogfile.990327.tmp
  logfile.990304.tmp  logfile.990312.tmp  logfile.990320.tmp ogfile.990328.tmp
  logfile.990305.tmp  logfile.990313.tmp  logfile.990321.tmp ogfile.990329.tmp
  logfile.990306.tmp  logfile.990314.tmp  logfile.990322.tmp ogfile.990330.tmp
  logfile.990307.tmp  logfile.990315.tmp  logfile.990323.tmp ogfile.990331.tmp
  logfile.990308.tmp  logfile.990316.tmp  logfile.990324.tmp
```

### 命令历史

在 UNIX SHELL 中，命令历史是你曾经 执行过的命令，这些命令被引用为**事件**。很多时候，回想以前执行的命令以节省输入是有效的。有时候，查看以前运行过的命令对了解当前状态也很有帮助。

Zsh 提供了两种方式来查看，执行，修改历史命令。一种方式是**历史扩展**。当你输入一个以“！”开头的命令时，它会被历史命令替换。（或者来自历史命令的一些独立单词）虽然这个机制非常强大和方便，它的语法还需要一点习惯。**第二个**方法来查看执行历史命令是 zsh 的内建函数 fc。尽管没有上一个方法那样方便，但是 fc 更容易理解。

#### 使用 fc

fc 是 zsh 的内建命令，能够让你查看、编辑、执行历史命令。

fc 有两种形式。

**第一种形式**

第一种形式可以让你灵活的选择历史命令，然后显示它们，或夹在他们来编辑或执行。

这种形式的语法如下：

> fc [-e EDITOR] \[OPTIONS] \[old = new ...] \[first  \[last]]
>
> 你可以使用负数来指定一个相对于当前命令行的事件。
>
> 默认：
>
> EDITOR NAME:
>
> 要使用的编辑器在EDITOR_NAME参数中指定。如果 EDITOR_NAME 没有指定，这个值是 shell 的参数 FCEDIT。
>
> first 和 last ：
>
> 你可以使用负数来指定一个相对于当前命令行的事件。若没有明确的值集合，first 默认为 ‘-1’（最近的命令），last 默认为 first 的值。
>
> 但是，如果只使用-1标志打印命令，first 默认为 “-16” 并且 last 默认为 “-1”。（打印最近的16个命令）

这会从 first 和 last 之间选择命令。

first 和 last 可以是数字和字符串。数字指的是事件的值。字符串指定最近的由字符串开始的命令。

在赋值 first 和 last 之后，你指定的替换器（old=new）会在命令中替换。所有出现的 old 都会被 new 替换。

- 第一种形式的参数

有时候，你只是想显示历史命令；你并不想编辑或者重新运行。通过 -l 选项，被选择的命令只是简单的显示；没有其他事情发生。（和输入 history 效果相同）

通过 -l ， fc 会在每个命令前面打印命令的数字。如果不想显示这些数字，可以使用 -n 参数。

有一些其他的标志和 -l 一起使用。要显示选择命令的时间戳，使用 -d 。如果你想要完整格式的时间戳，使用 -f 代替 -d。如果你不喜欢默认的时间戳格式。使用 -E，或者 -i 。 要显示命令之间的事件，使用 -D。

使用 -m 和 -l， 你可以指定一个模式。（不要忘记用引号）然后，只有符合模式的命令会被显示。

- 进入编辑器

对于第一种形式的任何其他参数，你需要进入编辑器。编辑器预先加载了一个只包含你在命令行指定的历史事件的文件。（每行一个历史事件）

编辑器的**关键思想**是，当你编辑完文件以后，文件内的所有命令都会被执行。

另一个方便的参数是 -r，无论是列出还是编辑。他将所选命令的顺序反转。

**fc 的第二种形式**

语法：

> fc -ARWI [ filename ]

- -R 会通过给定的文件读取历史记录
- -W 会写入历史命令到文件中
- -A 会增加历史命令到指定文件中
- 添加 -I 选项只会导致自上次增量追加后新增的事件 

在所有以上情况下，历史文件条目不会超过 $SAVEHIST 指定的数目。

#### 历史命令扩展

**历史命令扩展**是一种让你快速调用历史命令的方式。

一个历史命令扩展由 “！”开始。它可能出现在命令的任何地方，但是不会嵌套。如果你要在命令行中使用“！”符号，请使用引号。

在你输入 ENTER 以后， zsh 会评估之前所有的命令历史。然后打印出目前位置的命令行，然后继续进行其他类型的替换和扩展。

（有些人希望 shell 在处理命令的其余部分之前仔细检查这些历史扩展。具体的选项请参阅“[相关选项](https://www-s.acm.illinois.edu/workshops/zsh/related/hist_expn.html)"上的 HIST_VERIFY)

**一些方便的技巧**

- 你可以使用上下方向键循环查看历史命令。这仅仅适用于你的终端按键绑定到合适的编辑命令时。（查看 zsh 编辑器获取详细信息）
- 通过在命令行中输入**^ old ^ new**，您可以运行先前的任何旧命令替换为新命令。
- 您可以将事件放入历史列表中，而**无需**实际执行该命令。 你可以用print内建命令的-s参数来做到这一点。 

**语法**

历史命令扩展有三部分：**事件指示符**，**单词指示符**（可选），**单词修饰符**（可选）。语法如下：

[语法和用法注释](https://www-s.acm.illinois.edu/workshops/zsh/syntax_notes/hist_expn.html#1)

>designator [:word] \[:mod1:mod2...]

- 事件指示符

事件指示符只是您在命令行上键入的内容，它引用历史记录列表中的条目。 有许多有用的事件指示符，总结如下：
| 指示符   | 功能                                                       |
| -------- | ---------------------------------------------------------- |
| !        | 开始一个历史命令扩展，除非后面跟空格，换行符，‘=’ 或者 ‘(’ |
| !!       | 指前面的命令，这个扩展重复了前面的命令。                   |
| !n       | 指命令行n                                                  |
| !-n      | 指当前命令减n                                              |
| !str     | 指最近的以str 开头的命令                                   |
| !?str[?] | 指最近的包含str的命令                                      |
| !#       | 指截至目前为止的命令                                       |
| !{...}   | 隔离相邻字符的历史（如有必要）                             |

- 单词指示符

当参考历史命令时，你不需要恢复整个命令。可能你只需要历史命令的一部分，你可以使用**单词指示符**来指定哪个或者哪些单词你想要使用。简单从上面指定一个事件指示符，然后指定单词指示符。

下面是可用的单词指示符：
| 指示符 | 功能                     |
| ------ | ------------------------ |
| 0      | 第一个输入的单词         |
| n      | 第n个参数                |
| ^      | 第一个参数               |
| $      | 最后一个参数             |
| %      | 匹配？str 的单词         |
| x-y    | 一个范围的单词。x默认为0 |
| \*     | 所有的参数               |
| x\*    | x-$的缩写                |
| x-     | 像x\*一样，但是忽略$     |

**单词修饰符**

这是和文件名生成器和参数扩展一样的修饰符。查看[修饰符](https://www-s.acm.illinois.edu/workshops/zsh/modifiers.html)。

## Zsh 编程

### 参数：概述

在谈到 zsh 时，参数只是变量的另一个术语。就像其他的shell 和所有编程语言，一个变量只是某种类型的占位符。

在本书中，我们将同时互换的使用参数和变量。

在 zsh 中，一个参数有一个名称、一个关联的值和一些属性。

**参数名称**可以是字母、数字、下划线的任何组合序列。

**参数值**是变量存储的信息片段。参数值在 zsh 中可以是以下类型：字符串、整数 或者数组。

- **赋值**

最简单的赋值字符串或者数组的方式如下：

> name=value

赋值一个数组也是类似的：

> name=(value1 value2 value3 ... valueN)

要删除一个参数，只需要：

> unset PARAMETER_NAME

- **作用域**

Shell 函数为 shell 参数的作用域。这和一些编程语言类似。

当你读取或者设置一个变量时，zsh 查找**当前函数**来看变量是否存在。如果不存在，它会查找下一层的函数，一直下去，直到全局变量。因此，如果你为不存在的变量赋值，变量将在最外层的作用域中创建。（导出新的参数也有这个效果）

如果一个变量 X 超出范围，它将会被删除。（就像c语言一样）如果变量X存在于外部作用域中，它将会被使用。

- **位置参数**

位置参数包括当前运行的 shell 或 shell 脚本的参数。参数以数字 0 开头，并一直增加。在zsh中，它们可以**超过**9，（所以，$11是第十一个参数），$0 通常包含当前运行脚本或者shell的名称。

有三个数组包含所有的位置参数：@，*  和  argv。（它们之间有微小的区别，请查看手册）

位置参数可以由三种方式配置：

- 在shell调用时
- 使用内建函数 set
- 直接赋值

