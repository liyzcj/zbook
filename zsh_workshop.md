# Zsh Workshop

## 介绍

　　所有用户与 UNIX 系统交互的方式都是他们的SHELL。SHELL 为用户运行程序，从运行中的进程导入或导出数据。它给了用户一个完成 UNIX 工作的环境。

　　如果配置正确，UNIX SHELL 会让系统使用起来更加方便和简单。如果你的 SHELL 没有按照你的喜好来配置，使用它可能会导致效率大大降低，令人头疼，并且有时候会产生有害的、意想不到的效果。

　　**本书并不是试图让你使用zsh。**如果你已经使用一个 SHELL 15年了，你需要一个更好地理由将它换为 zsh。（也许本书会为你提供一点点）

　　本书的目的是**如何使用zsh让你的 UNIX 体验更加高效和愉快**。我会告诉你很多操作和配置zsh的方法。
　　
　　本书主要分为三个部分：
　　- 配置————让 zsh 的行为完全符合你希望的方式。
　　- 编程————利用一切可能充分利用脚本和函数。
　　- 技巧————大量的操作技巧和方法。

### 为什么选择 zsh？

　　Zsh 可以说是**最强大的和可配置的** UNIX SHELL。如果有的话，只有极少的事情其他 SHELL 可以做而 zsh 不能做。这也是为什么本书推荐 zsh 的原因。

　　简而言之，它可以让你用更少的时间完成更多的工作。

#### 特色

　　下面是一些 zsh 的特色。

<TABLE>
<TR COLSPAN=3>
<TD>别名
<TD>任务控制
<TD>函数

<TR>
<TD>简单灵活的 I/O 控制
<TD>目录堆栈
<TD>命令历史

<TR>
<TD>命令行编辑(vi, emacs, 自定义)
<TD>完全键盘映射
<TD>查找用户名

<TR>
<TD>登录/注销控制
<TD>高级文件名补全
<TD>主机名补全

<TR>
<TD>用户名补全
<TD>历史补全
<TD>完全编程补全

<TR>
<TD>SHELL受限模式
<TD>协同进程
<TD>内置算法评估

<TR>
<TD>隐藏符号链接
<TD>本地变量
<TD>定时命令

<TR>
<TD>简单可扩展提示符
<TD>拼写纠正
<TD>进程替换

<TR>
<TD>底层 sh 语法
<TD>处理大参数列表
<TD>避免用户setup file

<TR>
<TD>列出变量
<TD>全局别名
<TD>信号陷阱处理
</TABLE>

### 本书不包括

Zsh 的优点并不能简单的描述完全。以下是并不包含的内容，如果你对这些感兴趣，你可以自己去研究：

- 扩展参数标志

有很多方法可以获得 zsh 的扩展参数。比如

```shell
man zshexpn
```

- 命令行编辑

Zsh 的命令行编辑完全支持编程和绑定。你可以写自己的函数来控制光标和命令行的内容。zsh 还支持 **emacs**，**vi** 命令。执行以下命令了解详细信息：

```shell
man zshzle
```

- 动态加载模块

你可以编写自己的函数并实时的添加它。Zsh 中的许多东西都是作为模块实现的，例如完成控制。执行如下命令了解详细信息：

```shell
man zshmodules
```

- 构造语法

很遗憾我没有时间完成控制编程这部分。 例如 if for which case 等等。也许这部分会以后添加。

## 配置 ZSH

### 初始文件

像许多的 SHELL 一样，zsh 处理许多系统和用户的初始配置文件。了解这些文件的读取顺序和导致文件被忽略的情况非常重要。否则，你的命令或者起始配置文件可能不会被 zsh 执行。

#### 启动过程

在下面的描述中，zsh 默认会查找用户家目录下的配置文件。如果你希望它查找其他目录的配置文件，将参数 ZDOTDIR 设置为你想要的目录。

当 zsh 启动时，以下文件会被读取：

1. 读取 **/etc/zshenv**

如果在 **/etc/zshenv** 中未设置 **RCS** 选项，所有其他文件都会被跳过。

2. 读取 **~/.zshenv**
3. 如果 SHELL 为 login shell，读取 **/etc/zprofile**,然后是**~/.zprofile**
4. 如果 SHELL 为交互 SHELL ，读取 **/etc/zshrc**，然后是**~/.zshrc**
5. 最后，如果为 login shell，读取 **/etc/zlogin**，然后是 **~/.zlogin**
6. 当用户注销时，读取 **/etc/zlogout**，然后是 **~/.zlogout**

#### 术语解释

- **login shell**：登录 shell 一般在登录时产生，即当你使用 /bin/login 或者其他接入程序时，例如 SSH、rlogin、telnet等。例如：

```shell
ssh HOST_NAME SOME_COMMAND
```

即启动一个登录 shell

- **交互 SHELL ：交互 SHELL 是一个会显示提示并允许用户使用命令交互的 SHELL。

#### 注意

除了 /etc 还有**另一个**目录可以作为全局配置读取。可以再安装时确定。

### 通过选项配置 zsh

Zsh 有超过**一百多**个选项来控制 zsh 各方面的行为。每个选项都有一个名字，可以被打开或者关闭。

Zsh 提供了一些方法来打开或者关闭这些选项。最简单的可能是下面这个：

```shell
setopt OPTION_NAME   # 打开选项
unsetopt OPTION_NAME # 关闭选项
```

Zsh 的选项是大小写不敏感的，并且下划线会被忽略。这样可以使选项的名字简答易读。按照惯例一般全部大写。

任何一个选项都可以在前面加上 'NO' 来关闭。例如，如果你想关闭蜂鸣声，可以使用如下命令：

```shell
setopt NO_BEEP
```

有一些选项其实是其他选项的替代名称。这样有助于向后兼容 BASH 或者 KSH。（详情见手册）

### 提示符

Zsh 的提示符是**完全**可配置的。事实上，zsh 的提示符会获得它们自己的扩展类型。（如果你想在其他字符串上使用提示扩展，只需要 **-P** 参数指向 zsh 的内建函数 **print**）

Zsh 的**主要**提示符串包含在 SHELL 变量的 **PROMPT**中。这个变量也被称为 **PS1**。(它们是完全相同的，设置一个会影响另一个)

在 zsh 实际显示它们之前，提示符首先进行参数扩展，命令替换和算法扩展。（只有当 **PROMPT_SUBST** 选项打开时）

- 定制提示符

有些时候，每个人都想要定制自己独特的提示符。在 zsh 中有超过40个特殊的转移序列，允许你控制提示符中需要显示的信息。

像大多数 SHELL 一样，zsh 允许你在提示符中显示各种信息。当前时间、日期、主机信息或者当前目录等等。

Zsh 可以更进一步。它允许你截断你的提示，以便于它只占用命令行上一定的空间。它还为每个可显示的信息提供了许多不同的选项。它可以通过 **strftime(3)** 函数打印时间和日期。Zsh 在提示符中还支持 **“条件表示”**。这表示 zsh 可以根据特定的条件显示不同的提示信息。

在下面几个部分中，我们将讨论**所有可以使用的工具**来自定义你的提示符。

#### 在提示符中显示转移序列

通过特殊的**转义字符**定制你的提示符是非常简单但是重要的方法，有许多的**转义字符**代表不同的信息。大部分转移字符由符号**'%'**开始。然后，在 **PROMPT** 变量内，每一个转移字符都会由它们代表的信息代替。

一些转移字符可以使用可选的**整型参数**，它紧跟在**'%'**符号**之后**并在转移字符**之前**。

**转移序列和描述**

左边是转移字符，右边是它们代表的信息。

**注意**：新的转义字符可能会在以后添加。参考以下手册获取最新列表：

```shell
man zshmisc
```
- 字符

| 转义字符 | 代表信息 |
| -------- | -------- |
| %%       | %        |
| %)       | )        |

- 目录

| 转义字符 | 代表信息                              |
| -------- | ------------------------------------- |
| %d       | 当前目录-%PWD                         |
| %/       | 和%d相同                              |
| %~       | %PWD, 如果为%HOME，显示~              |
| %c       | PWD尾部组件。若想添加n个组件，使用%nc |
| %.       | 和%c相同                              |
| %C       | 与%c，%.相似，除了~不显示目录名称     |

- 主机名信息

| 转义字符 | 代表信息                               |
| -------- | -------------------------------------- |
| %M       | 全部主机名                             |
| %m       | 主机名到第一个'.' 可以使用%nm代表第n个 |

- 当前时间信息

| 转义字符 | 代表信息                      |
| -------- | ----------------------------- |
| %t       | 当前时间，12小时制，AM/PM格式 |
| %@       | 与%t相同                      |
| %T       | 当前时间，24小时制            |
| %\*      | 当前时间，24小时制，包含秒    |

- 当前日期

| 转义字符   | 代表信息                       |
| ---------- | ------------------------------ |
| %w         | 当前日期，day-dd 格式          |
| %W         | 当前日期，mm/dd/yy格式         |
| %D         | 当前日期，yy-mm-dd格式         |
| %D{string} | 字符串使用strftime函数格式化。 |

- 杂项

| 转义字符 | 代表信息                                |
| -------- | --------------------------------------- |
| %h       | 当前历史时间编号                        |
| %!       | 与%h相同                                |
| %L       | %SHLVL 的值                             |
| %n       | 等于 %USERNAME                          |
| %l       | 用户登录的行（tty）                     |
| %?       | 最后一个命令的返回码                    |
| %\_      | if for while 等等                       |
| %E       | 清除至行尾                              |
| %#       | 如果shell使用权限运行就是'#'，否则是‘%‘ |
| %v       | psvar数组参数的第一个元素的值           |

#### 提示符中的条件表示

在 zsh 提示符中，条件表达式是一个简单的取决于条件的表达式。你可以在你的提示符中根据条件使用它们来显示有用的信息。

要在你的提示符中使用条件表达式，使用以下的转义字符和语法：

> %(X.true-text.false-text)

以下内容直接取自手册。

> 指定一个三元表达式。跟在 X 后的符号是任意的；同样的符号用于区分结果为'真'的文本和结果为'假'的文本。这个分隔符不能出现在“true-text”中，除非作为转移字符。‘）’可能会出现在“false-text”中作为‘%）’。
>
> “true-text”和“false-text”可以任意的嵌套上一节中的转移字符，包括一个新的三元表达式。
>
> 左括号的前面可以添加一个正整数n，默认为0。‘X’可以取以下符号：
>
> | 符号  | 功能                                |
> | ----- | ----------------------------------- |
> | c . ~ | 若当前路径至少有n个前缀替换，则为真 |
> | / C   | 若当前绝对路径至少有n个元素，则为真 |
> | t     | 若当前分钟数等于n，则为真           |
> | T     | 若当前小时数等于n，则为真           |
> | d     | 若当前日等于n，则为真               |
> | D     | 若当前月等于n，则为真（一月为0）    |
> | w     | 若当前星期等于n，则为真（周一为0）  |
> | ？    | 若上一个命令的退出状态为n，则为真   |
> | #     | 若当前进程的有效uid等于n，则为真    |
> | g     | 若当前有效gid等于n，则为真          |
> | L     | 若参数SHLVL至少为n，则为真          |
> | S     | 若参数SECONDS至少为n，则为真        |
> | v     | 若psvar数组至少有n个元素，则为真    |
> | \_    | 若至少有n个构造器启动，则为真       |
> | ！    | 若SHELL使用特权运行，则为真         |

#### 格式化提示

你可以截断你的提示符以使用固定个数的空间。“man zshmisc” 查看详细信息，并查看PROMPT EXPANSION部分。

- 额外的格式转义

有一些额外的‘%’转义序列控制着 zsh 显示提示符的格式：

| 转义符 | 功能           |
| ------ | -------------- |
| %U     | 打开下划线模式 |
| %u     | 关闭下划线模式 |
| %B     | 打开粗体模式   |
| %b     | 关闭粗体模式   |
| %S     | 打开突出模式   |
| %s     | 关闭突出模式   |

> %{...%}
>
> 包含一个字符串代表转移序列。大括号内的字符串不应该改变光标位置。大括号可以嵌套，这可以用来在你的提示符中显示颜色。（见下文）

- 快速注释

如果你想在你的提示符中使用当前历史事件编号而不需要%转义序列，确保打开**PROMPT_BANG**选项。

这允许你在提示符中使用**‘  ！’**作为当前历史事件编号。如果你想要**‘  ！’**显示在你的提示符中，使用**‘  ！！’**。

### 查看其他用户

Zsh 为查看特定用户的登入和登出提供一种有效的方法，用户来自一个确定的主机或者一个确定的tty（终端）或者pty（虚拟终端）等等。

首先，我们看一下一个事件是什么，并举一个例子。然后，我们学习怎么将一个事件提供给 zsh 和怎样获取有用的zsh 报告。下一页，我们将学习怎么样自定义这些报告的外观。

#### 事件

对于本节来说，**事件**就是zsh 运行的主机上的任何登录和注销活动。

一个事件包含以下内容：

- 登录或注销的用户
- 用户连接的主机
- 用户连接的终端（tty）

要寻找特定用户相关的事件，只需要在事件说明中使用他们的用户名。

要寻找特定主机的事件，使用 “@” 后跟随主机名。

要寻找特定终端的事件，使用 “%” 后跟随终端名称。

这些元素中的任何一个或所有都可以用来指定事件。Zsh 会返回所有匹配指定元素的事件。

**实例**

匹配与用户 schrof 相关的事件的条目：

> schrof

匹配主机 nebcorp.com 并在虚拟终端 pts/19 的所有条目：

> @nebcorp.com%pts/19

匹配控制台上 root 用户的所有条目：

> root%console

#### 告诉 zsh 查找事件

你需要将 zsh 应该监视的事件列表放在 **watch** 或者 **WATCH** 变量中。这可以通过命令行完成，但是通常你更想设置一个同时设置另一个。如果这个 shell 被 sh 或者 ksh **调用**，你**必须**使用大写的 **WATCH** 变量。

正常情况下，你会分配给 watch 变量一个数组。 然而我们这里有两个特例：

1. 监视这个系统的**所有**时间，你可以简单的赋值 all 给 watch ：

> watch=all

2. 监视**除了**你意外的所有时间，你可以赋值 notme 给 watch ：

> watch=notme

否则，你需要分配一个事件列表：

> watch=(event1 event2 ... eventN)

然后 zsh 会报告所有配置你的设置的事件。

#### 获取报告

为 LOGCHECK 变量设置某个整数 n 会使 zsh 每 n 秒反馈一次报告（默认为60秒）。你可以随时通过运行 log 命令报告当前登录的受 watch 变量监视的用户。

下一节包含有关配置报告外观的详细信息。

#### 格式化登录、注销监视器

你可以随意定制事件报告的显示方式。通过在参数 WATCHFMT 中配置一个特殊的格式字符串。像各种提示参数一样，有许多有用的转义序列。。。

以下内容引用自手册：
| 转义序列 | 内容                     |
| -------- | ------------------------ |
| %n       | 用户的名称               |
| %a       | 时间的行为（登录、注销） |
| %l       | 使用的终端               |
| %M       | 全部的主机名             |
| %m       | 第一部分主机名。         |
| %S（%s） | 打开（关闭）突出模式     |
| %U（%u） | 打开（关闭）下划线模式   |
| %B（%b） | 打开关闭粗体模式         |
| %t 或 %@ | 时间，12小时制，am/pm    |
| %T       | 时间，24小时制           |
| %w       | 日期，day-dd格式         |
| %W       | 日期，mm/dd/yy格式       |
| %D       | 日期，yy-mm-dd格式       |

> %(X : true-text : false-text)

上面这个三元式和条件提示符非常相似。如果X为真，则显示 true-text，如果X为假，则显示 false-text。

“X” 可以指定为以下字符：‘l’，‘n’，‘m’，‘M’ 或 ‘a’。如果这些转义字符匹配到非零值，则为真。‘a’ 是一个特殊情况。如果是登录事件，则为真；如果为注销事件，则为假。

一些**提示**：

- 这些三元式可以**嵌套**
- true-text 和 false-text 可以为空
- 两个分隔符不可以**省略**

## 易用性

### 别名

#### 什么是别名

在大多数 SHELL 中，别名是用户**自定义**的命令的替代名称。它们经常被用来缩短命令长度，或者代表更常用的命令。例如，某用户可以定义 myprocs 来运行 ps -fu $LOGNAME。

Zsh 由以下方式定义别名。它有一个非常灵活和强大的系统来定义、使用和操作别名。

#### 别名是怎么工作的？

检查输入中的每个标记以确定是否为它定义了别名。如果定义了别名，这段字符会在以下情况被它定义的命令替换：

- 这个别名在命令的某个位置
- 别名是全局性
- 该行的上一个单词是一个以空格结尾的别名

#### 使用别名

Zsh 内建函数 alias 的语法如下

> alias [ -gmrL ]  \[name [=value] ...]

-r 参数表示 alias 命令为**常规模式**。 -g 参数表示 alias 为**全局模式**。若不加 -r 或者 -g 则对这两种类型都有效。

如果只写某个值，zsh 将打印名称和它的定义。若没有任何参数，alias 打印所有定义的 alias。

使用 -L 参数，别名的会剪切复制到你的启动脚本中。

要定义一个或多个别名，只需要输入：

> alias **name1=value1 name2=value2 ... nameN=valueN**

对于每个相应的名称，zsh 将使用该值定义一个别名。

#### 全局别名

即使你的别名不再命令中的第一个单词，zsh也允许你使用别名。这种别名称为 **全局别名**。

例如，假设你对你的 .procmailrc 文件做了许多工作。你运行了许多工具，例如 emacs，cp，less 等等。你不想为你的每个命令定义一个别名。这将会执行以下命令：

```shell
alias wprc="wc -l ~/.procmailrc"
alias cprc="cp ~/.procmailrc ~/.procmailrc.safe"
alias eprc="emacs ~/.procmailrc"
```

相反，你可以使用文件的全局别名。要定义一个全局别名，使用 -g 参数。

```shell
alias -g prc=~/.procmailrc
```

现在你可以简单的在任何地方查看你的 .procmailrc 文件：

```shell
lyric > emacs -nw prc
```

看[这里](https://www-s.acm.illinois.edu/workshops/zsh/related/messy_global.html)，如果你对一个不是那么强大的别名感兴趣。

#### 列出匹配模式的别名

你可以让 zsh 打印出那些符合给定模式的别名，而不是所有的。你可以添加参数 -m 到 alias 命令中。pattern 与文件名生成模式完全相同。事实上，你需要在 pattern 两边增加单引号以防止 zsh 将它当做文件名匹配模式。

#### 禁用和删除别名

你可以使用以下命令删除别名foo ： unalias foo

你也可以**临时**禁用别名foo ： disable -a foo

也可以重新激活它： enable -a foo

最后，你可能会有一个别名例如 ftp ，它实际上运行了一个不同的程序。如果你想要使用真正的 ftp 程序，在命令中使用 “=ftp” 或者 “\ftp”。

### cd：完整的故事

cd 用于更改你当前的工作目录。他可以通过各种方式使用。（你也可以使用cddir ，它们是完全相同的）

#### 第一种形式

对于几乎所有UNIX系统的 shell，cd 基本的用法如下：
| 输入       | 作用                          |
| ---------- | ----------------------------- |
| cd         | 切换到家目录，${HOME}         |
| cd NEW_DIR | 切换到某个目录                |
| cd -       | 切换到你刚才的目录，${OLDPWN} |

Zsh 为 cd 添加了一些有用的**函数**。

第一，如果 zsh 没有在当前目录找到 NEW_DIR（并且NEW_DIR不是一个绝对路径），zsh 会查询 shell 变量 **cdpath**。它会在 cdpath 的每个目录中查找子目录 NEW_DIR ， 如果找到NEW_DIR，就会转向那个目录。

此外，如果你喜欢，你可以将一个目录的完整路径存储在一个 shell 变量中。然后，你可以输入 cd VAR 进入包含在变量 VAR 中的路径。例如：

```shell
  lyric >  XDIR=/usr/lib/X11
  lyric >  cd XDIR
  ~XDIR
  lyric >  pwd
  /usr/lib/X11
```

为什么这个有用呢？为什么不直接输入$XDIR？原因是你可以获得其他的好处，本质上讲，这意味着这个目录可以迅速扩展和各种内建中得到特殊处理。

#### 第二种形式

第二种形式非常方便！输入：

```shell
cd OLD NEW
```

然后 zsh 使用NEW替换当前目录所有出现的OLD，并那个目录。

一个例子：

```shell
  lyric > pwd
  /usr/local/encap/fvwm-2.2/libexec/fvwm/2.2
  lyric > cd 2.2 2.0.46
  /usr/local/encap/fvwm-2.0.46/libexec/fvwm/2.0.46
  lyric > 
```

#### 第三种形式

第三种形式是从目录栈中抽取一个条目，并切换到该目录。（n 为一个整数）

```shell
cd +n
cd -n
```

要查看目录栈，输入

> dirs -v

给入参数 “+n” 会提取目录栈的第n个条目，从左边（上边）开始数。使用 “-n” 从右边（下边）开始数。

如果你想切换 ‘+’ 和 ‘-’ 的含义，请打开选项 PUSHD_MINUS。

#### cd 的参数

所有的 cd 形式都可以使用以下参数：
| 命令      | 功能                                 |
| --------- | ------------------------------------ |
| cd -s DIR | 如果DIR中包含链接，则不进入DIR       |
| cd -P DIR | 切换之前将所有符号链接设为真实值     |
| cd -L DIR | 遵循符号链接，忽略 CHASE_LILNKS 选项 |

**注意**： 打开选项 CHASE_LINKS 与 -P 效果相同。

## Zsh 编程

### 参数：概述

在谈到 zsh 时，参数只是变量的另一个术语。就像其他的shell 和所有编程语言，一个变量只是某种类型的占位符。

在本书中，我们将同时互换的使用参数和变量。

在 zsh 中，一个参数有一个名称、一个关联的值和一些属性。

**参数名称**可以是字母、数字、下划线的任何组合序列。

**参数值**是变量存储的信息片段。参数值在 zsh 中可以是以下类型：字符串、整数 或者数组。

- **赋值**

最简单的赋值字符串或者数组的方式如下：

> name=value

赋值一个数组也是类似的：

> name=(value1 value2 value3 ... valueN)

要删除一个参数，只需要：

> unset PARAMETER_NAME

- **作用域**

Shell 函数为 shell 参数的作用域。这和一些编程语言类似。

当你读取或者设置一个变量时，zsh 查找**当前函数**来看变量是否存在。如果不存在，它会查找下一层的函数，一直下去，直到全局变量。因此，如果你为不存在的变量赋值，变量将在最外层的作用域中创建。（导出新的参数也有这个效果）

如果一个变量 X 超出范围，它将会被删除。（就像c语言一样）如果变量X存在于外部作用域中，它将会被使用。

- **位置参数**

位置参数包括当前运行的 shell 或 shell 脚本的参数。参数以数字 0 开头，并一直增加。在zsh中，它们可以**超过**9，（所以，$11是第十一个参数），$0 通常包含当前运行脚本或者shell的名称。

有三个数组包含所有的位置参数：@，*  和  argv。（它们之间有微小的区别，请查看手册）

位置参数可以由三种方式配置：

- 在shell调用时
- 使用内建函数 set
- 直接赋值

