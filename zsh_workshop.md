# Zsh Workshop

作者：[Larry P. Schrof](mailto:larry@schrof.net)  翻译： [李岩锗](liyz0912@gmail.com) 

[**原文**](https://www-s.acm.illinois.edu/workshops/zsh/toc.html)

## 介绍

　　所有用户与 `UNIX` 系统交互的方式都是他们的`SHELL`。`SHELL` 为用户运行程序，从运行中的进程导入或导出数据。它给了用户一个完成 `UNIX` 工作的环境。

　　如果配置正确，`UNIX SHELL` 会让系统使用起来更加方便和简单。如果你的 `SHELL` 没有按照你的喜好来配置，使用它可能会导致效率大大降低，令人头疼，并且有时候会产生有害的、意想不到的效果。

　　**本书并不是试图让你使用`zsh`。**如果你已经使用一个 `SHELL`15年了，你需要一个更好地理由将它换为 `zsh`。（也许本书会为你提供一点点）

　　本书的目的是**如何使用`zsh`让你的 `UNIX` 体验更加高效和愉快**。我会告诉你很多操作和配置`zsh`的方法。
　　
　　本书主要分为三个部分：
　　- 配置————让 `zsh` 的行为完全符合你希望的方式。
　　- 编程————利用一切可能充分利用脚本和函数。
　　- 技巧————大量的操作技巧和方法。

### 为什么选择 zsh？

　　`Zsh` 可以说是**最强大的和可配置的** `UNIX SHELL`。如果有的话，只有极少的事情其他` SHELL` 可以做而 `zsh `不能做。这也是为什么本书推荐 `zsh` 的原因。

　　简而言之，它可以让你用更少的时间完成更多的工作。

**特色**

　　下面是一些 `zsh` 的特色。

<TABLE>
<TR COLSPAN=3>
<TD>别名
<TD>任务控制
<TD>函数

<TR>
<TD>简单灵活的 I/O 控制
<TD>目录堆栈
<TD>命令历史

<TR>
<TD>命令行编辑(vi, emacs, 自定义)
<TD>完全键盘映射
<TD>查找用户名

<TR>
<TD>登录/注销控制
<TD>高级文件名补全
<TD>主机名补全

<TR>
<TD>用户名补全
<TD>历史补全
<TD>完全编程补全

<TR>
<TD>SHELL受限模式
<TD>协同进程
<TD>内置算法评估

<TR>
<TD>隐藏符号链接
<TD>本地变量
<TD>定时命令

<TR>
<TD>简单可扩展提示符
<TD>拼写纠正
<TD>进程替换

<TR>
<TD>底层 sh 语法
<TD>处理大参数列表
<TD>避免用户setup file

<TR>
<TD>列出变量
<TD>全局别名
<TD>信号陷阱处理
</TABLE>

### 本书不包括

`Zsh` 的优点并不能简单的描述完全。以下是并不包含的内容，如果你对这些感兴趣，你可以自己去研究：

- 扩展参数标志

有很多方法可以获得 `zsh` 的扩展参数。比如

```shell
man zshexpn
```

- 命令行编辑

`Zsh` 的命令行编辑完全支持编程和绑定。你可以写自己的函数来控制光标和命令行的内容。`zsh` 还支持**`emacs`**，**`vi`** 命令。执行以下命令了解详细信息：

```shell
man zshzle
```

- 动态加载模块

你可以编写自己的函数并实时的添加它。`Zsh` 中的许多东西都是作为模块实现的，例如完成控制。执行如下命令了解详细信息：

```shell
man zshmodules
```

- 构造语法

很遗憾我没有时间完成控制编程这部分。 例如` if`, ` for`, ` which`, ` case` 等等。也许这部分会以后添加。

## 配置 ZSH

### 初始文件

像许多的 `SHELL` 一样，`zsh` 处理许多系统和用户的初始配置文件。了解这些文件的读取顺序和导致文件被忽略的情况非常重要。否则，你的命令或者起始配置文件可能不会被 `zsh` 执行。

**启动过程**

在下面的描述中，`zsh` 默认会查找用户家目录下的配置文件。如果你希望它查找其他目录的配置文件，将参数 `ZDOTDIR` 设置为你想要的目录。

当 `zsh` 启动时，以下文件会被读取：

1. 读取 **`/etc/zshenv`**

如果在 **`/etc/zshenv`** 中未设置 **`RCS`** 选项，所有其他文件都会被跳过。

2. 读取 **`~/.zshenv`**
3. 如果 `SHELL` 为 `login shell`，读取 **`/etc/zprofile`**,然后是**`~/.zprofile`**
4. 如果 `SHELL` 为交互 `SHELL` ，读取 **`/etc/zshrc`**，然后是**`~/.zshrc`**
5. 最后，如果为 `login shell`，读取 **`/etc/zlogin`**，然后是 **`~/.zlogin`**
6. 当用户注销时，读取 **`/etc/zlogout`**，然后是 **`~/.zlogout`**

**术语解释**

- **`login shell`**：登录 `shell` 一般在登录时产生，即当你使用 `/bin/login` 或者其他接入程序时，例如 `SSH`、`rlogin`、`telnet`等。例如：

```shell
ssh HOST_NAME SOME_COMMAND
```

即启动一个登录 `shell`

- **交互 `SHELL` ：交互 `SHELL` 是一个会显示提示并允许用户使用命令交互的 `SHELL`。

**注意**

除了 `/etc` 还有**另一个**目录可以作为全局配置读取。可以再安装时确定。

### 通过选项配置 `zsh`

`Zsh` 有超过**一百多**个选项来控制 `zsh` 各方面的行为。每个选项都有一个名字，可以被打开或者关闭。

`Zsh` 提供了一些方法来打开或者关闭这些选项。最简单的可能是下面这个：

```shell
setopt OPTION_NAME   # 打开选项
unsetopt OPTION_NAME # 关闭选项
```

`Zsh`的选项是大小写不敏感的，并且下划线会被忽略。这样可以使选项的名字简答易读。按照惯例一般全部大写。

任何一个选项都可以在前面加上 `NO` 来关闭。例如，如果你想关闭蜂鸣声，可以使用如下命令：

```shell
setopt NO_BEEP
```

有一些选项其实是其他选项的替代名称。这样有助于向后兼容 `BASH` 或者 `KSH`。（详情见手册）

### 提示符

`Zsh` 的提示符是**完全**可配置的。事实上，`zsh` 的提示符会获得它们自己的扩展类型。（如果你想在其他字符串上使用提示扩展，只需要 **`-P`** 参数指向 `zsh` 的内建函数 **`print`**）

`Zsh` 的**主要**提示符串包含在 `SHELL` 变量的 **`PROMPT`**中。这个变量也被称为 **`PS1`**。(它们是完全相同的，设置一个会影响另一个)

在 `zsh` 实际显示它们之前，提示符首先进行参数扩展，命令替换和算法扩展。（只有当 **`PROMPT_SUBST`** 选项打开时）

- 定制提示符

有些时候，每个人都想要定制自己独特的提示符。在 `zsh` 中有超过40个特殊的转移序列，允许你控制提示符中需要显示的信息。

像大多数 `SHELL` 一样，`zsh` 允许你在提示符中显示各种信息。当前时间、日期、主机信息或者当前目录等等。

`Zsh` 可以更进一步。它允许你截断你的提示，以便于它只占用命令行上一定的空间。它还为每个可显示的信息提供了许多不同的选项。它可以通过 **`strftime(3)`** 函数打印时间和日期。`Zsh` 在提示符中还支持 **“条件表示”**。这表示 `zsh` 可以根据特定的条件显示不同的提示信息。

在下面几个部分中，我们将讨论**所有可以使用的工具**来自定义你的提示符。

#### 在提示符中显示转移序列

通过特殊的**转义字符**定制你的提示符是非常简单但是重要的方法，有许多的**转义字符**代表不同的信息。大部分转移字符由符号**`%`**开始。然后，在 **`PROMPT`** 变量内，每一个转移字符都会由它们代表的信息代替。

一些转移字符可以使用可选的**整型参数**，它紧跟在**`%`**符号**之后**并在转移字符**之前**。

**转移序列和描述**

左边是转移字符，右边是它们代表的信息。

**注意**：新的转义字符可能会在以后添加。参考以下手册获取最新列表：

```shell
man zshmisc
```
- 字符

| 转义字符 | 代表信息 |
| -------- | -------- |
| `%%`     | `%`      |
| `%)`     | `)`      |

- 目录

| 转义字符 | 代表信息                                    |
| -------- | ------------------------------------------- |
| `%d`     | 当前目录`%PWD`                              |
| `%/`     | 和`%d`相同                                  |
| `%~`     | `%PWD`, 如果为`%HOME`，显示`~`              |
| `%c`     | `PWD`尾部组件。若想添加`n`个组件，使用`%nc` |
| `%.`     | 和`%c`相同                                  |
| `%C`     | 与`%c`，`%`.相似，除了`~`不显示目录名称     |

- 主机名信息

| 转义字符 | 代表信息                                   |
| -------- | ------------------------------------------ |
| `%M`     | 全部主机名                                 |
| `%m`     | 主机名到第一个`.` 可以使用`%nm`代表第`n`个 |

- 当前时间信息

| 转义字符 | 代表信息                        |
| -------- | ------------------------------- |
| `%t`     | 当前时间，12小时制，`AM/PM`格式 |
| `%@`     | 与`%t`相同                      |
| `%T`     | 当前时间，24小时制              |
| `%*`     | 当前时间，24小时制，包含秒      |

- 当前日期

| 转义字符     | 代表信息                         |
| ------------ | -------------------------------- |
| `%w`         | 当前日期，`day-dd` 格式          |
| `%W`         | 当前日期，`mm/dd/yy`格式         |
| `%D`         | 当前日期，`yy-mm-dd`格式         |
| `%D{string}` | 字符串使用`strftime`函数格式化。 |

- 杂项

| 转义字符 | 代表信息                                  |
| -------- | ----------------------------------------- |
| `%h`     | 当前历史时间编号                          |
| `%!`     | 与`%h`相同                                |
| `%L`     | `%SHLVL` 的值                             |
| `%n`     | 等于 `%USERNAME`                          |
| `%l`     | 用户登录的行（`tty`）                     |
| `%?`     | 最后一个命令的返回码                      |
| `%_`     |                                           |
| `%E`     | 清除至行尾                                |
| `%#`     | 如果`shell`使用权限运行就是`#`，否则是`%` |
| `%v`     | `psvar`数组参数的第一个元素的值           |

#### 提示符中的条件表示

在 `zsh` 提示符中，条件表达式是一个简单的取决于条件的表达式。你可以在你的提示符中根据条件使用它们来显示有用的信息。

要在你的提示符中使用条件表达式，使用以下的转义字符和语法：

> %(X.true-text.false-text)

以下内容直接取自手册。

> 指定一个三元表达式。跟在 X 后的符号是任意的；同样的符号用于区分结果为'真'的文本和结果为'假'的文本。这个分隔符不能出现在“true-text”中，除非作为转移字符。‘）’可能会出现在“false-text”中作为‘%）’。
>
> “true-text”和“false-text”可以任意的嵌套上一节中的转移字符，包括一个新的三元表达式。
>
> 左括号的前面可以添加一个正整数n，默认为0。‘X’可以取以下符号：
>
> | 符号  | 功能                                |
> | ----- | ----------------------------------- |
> | c . ~ | 若当前路径至少有n个前缀替换，则为真 |
> | / C   | 若当前绝对路径至少有n个元素，则为真 |
> | t     | 若当前分钟数等于n，则为真           |
> | T     | 若当前小时数等于n，则为真           |
> | d     | 若当前日等于n，则为真               |
> | D     | 若当前月等于n，则为真（一月为0）    |
> | w     | 若当前星期等于n，则为真（周一为0）  |
> | ？    | 若上一个命令的退出状态为n，则为真   |
> | #     | 若当前进程的有效uid等于n，则为真    |
> | g     | 若当前有效gid等于n，则为真          |
> | L     | 若参数SHLVL至少为n，则为真          |
> | S     | 若参数SECONDS至少为n，则为真        |
> | v     | 若psvar数组至少有n个元素，则为真    |
> | \_    | 若至少有n个构造器启动，则为真       |
> | ！    | 若SHELL使用特权运行，则为真         |

#### 格式化提示

你可以截断你的提示符以使用固定个数的空间。`man zshmisc` 查看详细信息，并查看`PROMPT EXPANSION`部分。

- 额外的格式转义

有一些额外的`%`转义序列控制着 `zsh` 显示提示符的格式：

| 转义符 | 功能           |
| ------ | -------------- |
| `%U`   | 打开下划线模式 |
| `%u`   | 关闭下划线模式 |
| `%B`   | 打开粗体模式   |
| `%b`   | 关闭粗体模式   |
| `%S`   | 打开突出模式   |
| `%s`   | 关闭突出模式   |

> %{...%}
>
> 包含一个字符串代表转移序列。大括号内的字符串不应该改变光标位置。大括号可以嵌套，这可以用来在你的提示符中显示颜色。（见下文）

- 快速注释

如果你想在你的提示符中使用当前历史事件编号而不需要%转义序列，确保打开**`PROMPT_BANG`**选项。

这允许你在提示符中使用**` !`**作为当前历史事件编号。如果你想要**`!`**显示在你的提示符中，使用**` !!`**。

### 查看其他用户

`Zsh` 为查看特定用户的登入和登出提供一种有效的方法，用户来自一个确定的主机或者一个确定的`tty`（终端）或者`pty`（虚拟终端）等等。

首先，我们看一下一个事件是什么，并举一个例子。然后，我们学习怎么将一个事件提供给 `zsh` 和怎样获取有用的`zsh` 报告。下一页，我们将学习怎么样自定义这些报告的外观。

**事件**

对于本节来说，**事件**就是`zsh` 运行的主机上的任何登录和注销活动。

一个事件包含以下内容：

- 登录或注销的用户
- 用户连接的主机
- 用户连接的终端（`tty`）

要寻找特定用户相关的事件，只需要在事件说明中使用他们的用户名。

要寻找特定主机的事件，使用 `@` 后跟随主机名。

要寻找特定终端的事件，使用 `%` 后跟随终端名称。

这些元素中的任何一个或所有都可以用来指定事件。`Zsh` 会返回所有匹配指定元素的事件。

**实例**

匹配与用户 `schrof` 相关的事件的条目：

> schrof

匹配主机 `nebcorp.com` 并在虚拟终端 `pts/19` 的所有条目：

> @nebcorp.com%pts/19

匹配控制台上 `root` 用户的所有条目：

> root%console

**告诉 `zsh` 查找事件**

你需要将 `zsh` 应该监视的事件列表放在 **`watch`** 或者 **`WATCH`** 变量中。这可以通过命令行完成，但是通常你更想设置一个同时设置另一个。如果这个 `shell` 被 `sh` 或者 `ksh` **调用**，你**必须**使用大写的 **`WATCH`** 变量。

正常情况下，你会分配给 `watch` 变量一个数组。 然而我们这里有两个特例：

1. 监视这个系统的**所有**时间，你可以简单的赋值 `all` 给 `watch` ：

> watch=all

2. 监视**除了**你意外的所有时间，你可以赋值 `notme` 给 `watch` ：

> watch=notme

否则，你需要分配一个事件列表：

> watch=(event1 event2 ... eventN)

然后 `zsh` 会报告所有配置你的设置的事件。

**获取报告**

为 `LOGCHECK` 变量设置某个整数 `n`会使 `zsh` 每 `n` 秒反馈一次报告（默认为60秒）。你可以随时通过运行 `log` 命令报告当前登录的受 `watch` 变量监视的用户。

下一节包含有关配置报告外观的详细信息。

#### 格式化登录、注销监视器

你可以随意定制事件报告的显示方式。通过在参数 `WATCHFMT` 中配置一个特殊的格式字符串。像各种提示参数一样，有许多有用的转义序列。。。

以下内容引用自手册：
| 转义序列     | 内容                     |
| ------------ | ------------------------ |
| `%n`         | 用户的名称               |
| `%a`         | 时间的行为（登录、注销） |
| `%l`         | 使用的终端               |
| `%M`         | 全部的主机名             |
| `%m`         | 第一部分主机名。         |
| `%S`（`%s`） | 打开（关闭）突出模式     |
| `%U`（`%u`） | 打开（关闭）下划线模式   |
| `%B`（`%b`） | 打开关闭粗体模式         |
| `%t` 或 `%@` | 时间，12小时制，`am/pm`  |
| `%T`         | 时间，24小时制           |
| `%w`         | 日期，`day-dd`格式       |
| `%W`         | 日期，`mm/dd/yy`格式     |
| `%D`         | 日期，`yy-mm-dd`格式     |

> %(X : true-text : false-text)

上面这个三元式和条件提示符非常相似。如果X为真，则显示 `true-text`，如果X为假，则显示 `false-text`。

`X` 可以指定为以下字符：`l`，`n`，`m`，`M` 或`a`。如果这些转义字符匹配到非零值，则为真。`a` 是一个特殊情况。如果是登录事件，则为真；如果为注销事件，则为假。

一些**提示**：

- 这些三元式可以**嵌套**
- `true-text` 和 `false-text` 可以为空
- 两个分隔符不可以**省略**

## 易用性

### 别名

**什么是别名**

在大多数 `SHELL` 中，别名是用户**自定义**的命令的替代名称。它们经常被用来缩短命令长度，或者代表更常用的命令。例如，某用户可以定义 `myprocs` 来运行 `ps -fu $LOGNAME`。

`Zsh` 由以下方式定义别名。它有一个非常灵活和强大的系统来定义、使用和操作别名。

**别名是怎么工作的？**

检查输入中的每个标记以确定是否为它定义了别名。如果定义了别名，这段字符会在以下情况被它定义的命令替换：

- 这个别名在命令的某个位置
- 别名是全局性
- 该行的上一个单词是一个以空格结尾的别名

**使用别名**

`Zsh` 内建函数 `alias` 的语法如下

> alias [ -gmrL ]  \[name [=value] ...]

`-r` 参数表示 `alias` 命令为**常规模式**。 `-g` 参数表示 `alias` 为**全局模式**。若不加 `-r` 或者 `-g` 则对这两种类型都有效。

如果只写某个值，`zsh` 将打印名称和它的定义。若没有任何参数，`alias` 打印所有定义的 `alias`。

使用 -L 参数，别名的会剪切复制到你的启动脚本中。

要定义一个或多个别名，只需要输入：

> alias **name1=value1 name2=value2 ... nameN=valueN**

对于每个相应的名称，`zsh` 将使用该值定义一个别名。

**全局别名**

即使你的别名不再命令中的第一个单词，`zsh`也允许你使用别名。这种别名称为 **全局别名**。

例如，假设你对你的 `.procmailrc` 文件做了许多工作。你运行了许多工具，例如 `emacs`，`cp`，`less` 等等。你不想为你的每个命令定义一个别名。这将会执行以下命令：

```shell
alias wprc="wc -l ~/.procmailrc"
alias cprc="cp ~/.procmailrc ~/.procmailrc.safe"
alias eprc="emacs ~/.procmailrc"
```

相反，你可以使用文件的全局别名。要定义一个全局别名，使用 `-g` 参数。

```shell
alias -g prc=~/.procmailrc
```

现在你可以简单的在任何地方查看你的 `.procmailrc` 文件：

```shell
lyric > emacs -nw prc
```

看[这里](https://www-s.acm.illinois.edu/workshops/zsh/related/messy_global.html)，如果你对一个不是那么强大的别名感兴趣。

**列出匹配模式的别名**

你可以让` zsh` 打印出那些符合给定模式的别名，而不是所有的。你可以添加参数 `-m`到 `alias` 命令中。`pattern` 与文件名生成模式完全相同。事实上，你需要在 `pattern` 两边增加单引号以防止 `zsh` 将它当做文件名匹配模式。

**禁用和删除别名**

你可以使用以下命令删除别名`foo` ： `unalias foo`

你也可以**临时**禁用别名`foo` ： `disable -a foo`

也可以重新激活它： `enable -a foo`

最后，你可能会有一个别名例如 `ftp` ，它实际上运行了一个不同的程序。如果你想要使用真正的 `ftp` 程序，在命令中使用 `=ftp` 或者 `\ftp`。

### `cd`：完整的故事

`cd` 用于更改你当前的工作目录。他可以通过各种方式使用。（你也可以使用`cddir` ，它们是完全相同的）

**第一种形式**

对于几乎所有`UNIX`系统的 `shell`，`cd` 基本的用法如下：
| 输入         | 作用                            |
| ------------ | ------------------------------- |
| `cd`         | 切换到家目录，`${HOME}`         |
| `cd NEW_DIR` | 切换到某个目录                  |
| `cd -`       | 切换到你刚才的目录，`${OLDPWN}` |

`Zsh` 为 `cd `添加了一些有用的**函数**。

第一，如果 `zsh` 没有在当前目录找到 `NEW_DIR`（并且`NEW_DIR`不是一个绝对路径），`zsh` 会查询 `shell` 变量**`cdpath`**。它会在 `cdpath` 的每个目录中查找子目录 `NEW_DIR` ， 如果找到`NEW_DIR`，就会转向那个目录。

此外，如果你喜欢，你可以将一个目录的完整路径存储在一个 `shell` 变量中。然后，你可以输入 `cd VAR` 进入包含在变量 `VAR`中的路径。例如：

```shell
  lyric >  XDIR=/usr/lib/X11
  lyric >  cd XDIR
  ~XDIR
  lyric >  pwd
  /usr/lib/X11
```

为什么这个有用呢？为什么不直接输入`$XDIR`？原因是你可以获得其他的好处，本质上讲，这意味着这个目录可以迅速扩展和各种内建中得到特殊处理。

**第二种形式**

第二种形式非常方便！输入：

```shell
cd OLD NEW
```

然后 `zsh` 使用`NEW`替换当前目录所有出现的`OLD`，并那个目录。

一个例子：

```shell
  lyric > pwd
  /usr/local/encap/fvwm-2.2/libexec/fvwm/2.2
  lyric > cd 2.2 2.0.46
  /usr/local/encap/fvwm-2.0.46/libexec/fvwm/2.0.46
  lyric > 
```

**第三种形式**

第三种形式是从目录栈中抽取一个条目，并切换到该目录。（`n` 为一个整数）

```shell
cd +n
cd -n
```

要查看目录栈，输入

> dirs -v

给入参数 `+n`会提取目录栈的第`n`个条目，从左边（上边）开始数。使用 `-n` 从右边（下边）开始数。

如果你想切换 `+` 和 `-` 的含义，请打开选项 `PUSHD_MINUS`。

**`cd` 的参数**

所有的 `cd` 形式都可以使用以下参数：
| 命令        | 功能                                   |
| ----------- | -------------------------------------- |
| `cd -s DIR` | 如果`DIR`中包含链接，则不进入`DIR`     |
| `cd -P DIR` | 切换之前将所有符号链接设为真实值       |
| `cd -L DIR` | 遵循符号链接，忽略 `CHASE_LILNKS` 选项 |

**注意**： 打开选项 `CHASE_LINKS` 与 `-P` 效果相同。

### 目录栈

`Zsh` 有一个内置的目录栈。这个工具可以帮助你在整个 `zsh` 会话中管理许多不同的工作。

**使用方法**

使用 **`pushd`** 命令将目录放置到目录堆栈中。使用 **`popd`** 将目录从堆栈中移除。可以使用 **`dirs`** 命令查看或者重建堆栈。

要查看堆栈的内容，只需要简单的输入以下指令（没有参数也可以但是输出不易读）：

```shell
  > dirs -v
  0       /etc/mail
  1       /var
  2       /tmp
  3       /usr/local
  4       /usr
  5       ~
  >
```

如果你要重建堆栈，使用 **`dirs`** 后面跟目录名称列表。`zsh` 会执行以下步骤：

- 删除堆栈的所有目录
- 从最右边开始将所有参数放入堆栈
- 将 `$PWD` 放入堆栈最上面

```shell
  > echo $PWD
  /tmp
  > dirs /usr/local/ews /usr/local /usr /var /var/log $HOME
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr/local
  3       /usr
  4       /var
  5       /var/log
  6       ~
  >
```

**`popd`**

`popd` 从堆栈中删除条目，并 `cd` 到最新的顶层目录。

行为

- 没有参数时，从堆栈中删除当前顶层目录项，并将`cd`移到新的顶层目录。 
- `popd` 可以带一个参数 `+n` 或 `-n` ，`n`是一个整数。
  - `+n`，会删除从顶部起第`n`个元素
  - `-n`，会删除从底部起第`n`个元素
- 计数从零开始
- 如果你打开选项 `PUSHD_MINUS`，`+` 和 `-` 的意义会相反。

```shell
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr/local
  3       /usr
  4       /var
  5       /var/log
  6       ~
  > setopt PUSHD_MINUS
  > popd -2
  > echo $PWD
  /tmp
  > dirs -v
  0       /tmp
  1       /usr/local/ews
  2       /usr
  3       /var
  4       /var/log
  5       ~
  > popd
  > echo $PWD
  /usr/local/ews
  > dirs -v
  0       /usr/local/ews
  1       /usr
  2       /var
  3       /var/log
  4       ~
  >
```

**`pushd`**

`pushd` 修改当前目录到一个你指定的参数，并将 `$OLDPWD` 的内容入栈。

- 第一种形式：`pushd [arg]`

修改当前目录到 `arg`。如果 `arg` 没有指定，跳转到第二个元素。

```shell
  > pwd
  /etc
  > dirs -v
  0       /etc
  1       /usr/local/ews
  > pushd mail
  > dirs -v
  0       /etc/mail
  1       /etc
  2       /usr/local/ews
```

**注意**：如果选项 `PUSHD_TO_HOME` 打开，或者只有一个元素在堆栈内，`pushd` 更改当前目录到 `$HOME`。

如果 `arg` 是 `-`，`pushd` 修改目录到 `$OLDPWD`。如果 `arg` 在当前目录找不到，并且 `arg` 不包含 `/`，`zsh` 会查找参数 `cdpath` 的每一个条目。如果选项 `CDABLE_VARS` 打开，并且变量名 `arg` 存在并包含一个完整路径，会将 `arg` 的值作为目录。

如果选项 `PUSHD_SILENT` 没有打开，目录堆栈会在 `pushd` 命令后被打印。

- 第二种形式：`pushd old new`

`pushd` 使用 `new` 替换 `old` ， 并尝试切换到这个新的目录。（和 `cd` 的第二种形式相似）

- 第三种形式：`pushd ｛+ | -｝n`

使 `pushd` 通过旋转堆栈来更改当前目录。参数 `n` 在 `popd` 中已经描述。

```shell
  > setopt PUSHD_MINUS
  > dirs -v
  0       /etc/mail
  1       /usr/local
  2       /usr
  3       ~
  > pushd -2
  /usr
  > dirs -v
  0       /usr
  1       ~
  2       /etc/mail
  3       /usr/local
```

**文件名扩展和目录堆栈**

`Zsh`提供了一种在日常工作中快速引用目录堆栈的好方法。 以下说明直接从手册页获取： 

>  后跟一个数字的`〜`被目录堆栈中的那个位置替换。 `〜0`相当于`〜+`，`〜1`是堆栈的顶部。`〜+`后面跟着一个数字被堆栈中那个位置替换。`〜+0`等于`〜+`，`〜+1`是堆栈的顶部。`〜-`后面跟着一个数字被堆栈中从底部开始的那个位置替换。`〜-0`是堆栈的底部。选项 `PUSHD_MINUS` 交换 `+` 和 `-` 的影响。

### 大括号扩展

大括号扩展是一个方便的功能，它允许你在命令行上快速的生成项目列表。

一个这种格式的字符串 **`str {xx, yy, zz} ing`** 会被扩展为独立的单词 **`strxxing, stryying, strzzing`**。顺序从左到右。

实例：

```shell
  > ls -l array{5d,MYd,BIG}
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 array5d
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 arrayBIG
  -rw-r--r--   1 l-schro    stdt             0 Apr 19 17:16 arrayMYd
```

如果形式为`{n1..n2}`，其中 `n1`，`n2` 是整数，则结果为从 `n1` 到 `n2` 的所有数字。如果任何一个数字从零开始，则所有的数字都以零为开头填充。

实例：

```shell
  > touch logfile.9908{01..31}.tmp
  > ls logfile*
  logfile.990301.tmp  logfile.990309.tmp  logfile.990317.tmp ogfile.990325.tmp
  logfile.990302.tmp  logfile.990310.tmp  logfile.990318.tmp ogfile.990326.tmp
  logfile.990303.tmp  logfile.990311.tmp  logfile.990319.tmp ogfile.990327.tmp
  logfile.990304.tmp  logfile.990312.tmp  logfile.990320.tmp ogfile.990328.tmp
  logfile.990305.tmp  logfile.990313.tmp  logfile.990321.tmp ogfile.990329.tmp
  logfile.990306.tmp  logfile.990314.tmp  logfile.990322.tmp ogfile.990330.tmp
  logfile.990307.tmp  logfile.990315.tmp  logfile.990323.tmp ogfile.990331.tmp
  logfile.990308.tmp  logfile.990316.tmp  logfile.990324.tmp
```

### 命令历史

在 `UNIX SHELL` 中，命令历史是你曾经 执行过的命令，这些命令被引用为**事件**。很多时候，回想以前执行的命令以节省输入是有效的。有时候，查看以前运行过的命令对了解当前状态也很有帮助。

`Zsh` 提供了两种方式来查看，执行，修改历史命令。一种方式是**历史扩展**。当你输入一个以`!`开头的命令时，它会被历史命令替换。（或者来自历史命令的一些独立单词）虽然这个机制非常强大和方便，它的语法还需要一点习惯。**第二个**方法来查看执行历史命令是 `zsh` 的内建函数 `fc`。尽管没有上一个方法那样方便，但是 `fc` 更容易理解。

#### 使用 `fc`

`fc` 是 `zsh` 的内建命令，能够让你查看、编辑、执行历史命令。

`fc` 有两种形式。

**第一种形式**

第一种形式可以让你灵活的选择历史命令，然后显示它们，或夹在他们来编辑或执行。

这种形式的语法如下：

> fc [-e EDITOR] \[OPTIONS] \[old = new ...] \[first  \[last]]
>
> 你可以使用负数来指定一个相对于当前命令行的事件。
>
> 默认：
>
> EDITOR NAME:
>
> 要使用的编辑器在EDITOR_NAME参数中指定。如果 EDITOR_NAME 没有指定，这个值是 shell 的参数 FCEDIT。
>
> first 和 last ：
>
> 你可以使用负数来指定一个相对于当前命令行的事件。若没有明确的值集合，first 默认为 ‘-1’（最近的命令），last 默认为 first 的值。
>
> 但是，如果只使用-1标志打印命令，first 默认为 “-16” 并且 last 默认为 “-1”。（打印最近的16个命令）

这会从 `first` 和 `last` 之间选择命令。

`first` 和 `last` 可以是数字和字符串。数字指的是事件的值。字符串指定最近的由字符串开始的命令。

在赋值 `first` 和 `last` 之后，你指定的替换器`（old=new）`会在命令中替换。所有出现的 `old` 都会被 `new` 替换。

- 第一种形式的参数

有时候，你只是想显示历史命令；你并不想编辑或者重新运行。通过 -l 选项，被选择的命令只是简单的显示；没有其他事情发生。（和输入 `history` 效果相同）

通过 `-l` ， `fc` 会在每个命令前面打印命令的数字。如果不想显示这些数字，可以使用 `-n` 参数。

有一些其他的标志和 `-l` 一起使用。要显示选择命令的时间戳，使用 `-d`。如果你想要完整格式的时间戳，使用 -f 代替 `-d`。如果你不喜欢默认的时间戳格式。使用 `-E`，或者 `-i` 。 要显示命令之间的事件，使用 `-D`。

使用 `-m` 和 `-l`， 你可以指定一个模式。（不要忘记用引号）然后，只有符合模式的命令会被显示。

- 进入编辑器

对于第一种形式的任何其他参数，你需要进入编辑器。编辑器预先加载了一个只包含你在命令行指定的历史事件的文件。（每行一个历史事件）

编辑器的**关键思想**是，当你编辑完文件以后，文件内的所有命令都会被执行。

另一个方便的参数是 `-r`，无论是列出还是编辑。他将所选命令的顺序反转。

**`fc` 的第二种形式**

语法：

> fc -ARWI [ filename ]

- `-R` 会通过给定的文件读取历史记录
- `-W` 会写入历史命令到文件中
- `-A` 会增加历史命令到指定文件中
- 添加 `-I` 选项只会导致自上次增量追加后新增的事件 

在所有以上情况下，历史文件条目不会超过 `$SAVEHIST` 指定的数目。

#### 历史命令扩展

**历史命令扩展**是一种让你快速调用历史命令的方式。

一个历史命令扩展由 `!`开始。它可能出现在命令的任何地方，但是不会嵌套。如果你要在命令行中使用“！”符号，请使用引号。

在你输入 `ENTER` 以后， `zsh` 会评估之前所有的命令历史。然后打印出目前位置的命令行，然后继续进行其他类型的替换和扩展。

（有些人希望 `shell` 在处理命令的其余部分之前仔细检查这些历史扩展。具体的选项请参阅“[相关选项](https://www-s.acm.illinois.edu/workshops/zsh/related/hist_expn.html)"上的 `HIST_VERIFY`)

**一些方便的技巧**

- 你可以使用上下方向键循环查看历史命令。这仅仅适用于你的终端按键绑定到合适的编辑命令时。（查看 `zsh` 编辑器获取详细信息）
- 通过在命令行中输入**`^ old ^ new`**，您可以运行先前的任何旧命令替换为新命令。
- 您可以将事件放入历史列表中，而**无需**实际执行该命令。 你可以用`print`内建命令的`-s`参数来做到这一点。 

**语法**

历史命令扩展有三部分：**事件指示符**，**单词指示符**（可选），**单词修饰符**（可选）。语法如下：

[语法和用法注释](https://www-s.acm.illinois.edu/workshops/zsh/syntax_notes/hist_expn.html#1)

>designator [:word] \[:mod1:mod2...]

- 事件指示符

事件指示符只是您在命令行上键入的内容，它引用历史记录列表中的条目。 有许多有用的事件指示符，总结如下：
| 指示符     | 功能                                                       |
| ---------- | ---------------------------------------------------------- |
| `!`        | 开始一个历史命令扩展，除非后面跟空格，换行符，`=` 或者 `(` |
| `!!`       | 指前面的命令，这个扩展重复了前面的命令。                   |
| `!n`       | 指命令行`n`                                                |
| `!-n`      | 指当前命令减n                                              |
| `!str`     | 指最近的以`str` 开头的命令                                 |
| `!?str[?]` | 指最近的包含`str`的命令                                    |
| `!#`       | 指截至目前为止的命令                                       |
| `!{...}`   | 隔离相邻字符的历史（如有必要）                             |

- 单词指示符

当参考历史命令时，你不需要恢复整个命令。可能你只需要历史命令的一部分，你可以使用**单词指示符**来指定哪个或者哪些单词你想要使用。简单从上面指定一个事件指示符，然后指定单词指示符。

下面是可用的单词指示符：
| 指示符 | 功能                         |
| ------ | ---------------------------- |
| `0`    | 第一个输入的单词             |
| `n`    | 第n个参数                    |
| `^`    | 第一个参数                   |
| `$`    | 最后一个参数                 |
| `%`    | 匹配`str` 的单词             |
| `x-y`  | 一个范围的单词。`x`默认为`0` |
| `*`    | 所有的参数                   |
| `x*`   | `x-$`的缩写                  |
| `x-`   | 像`x*`一样，但是忽略`$`      |

**单词修饰符**

这是和文件名生成器和参数扩展一样的修饰符。查看[修饰符](https://www-s.acm.illinois.edu/workshops/zsh/modifiers.html)。

## `Zsh` 编程

### 参数：概述

在谈到 `zsh` 时，参数只是变量的另一个术语。就像其他的`shell` 和所有编程语言，一个变量只是某种类型的占位符。

在本书中，我们将同时互换的使用参数和变量。

在 `zsh` 中，一个参数有一个名称、一个关联的值和一些属性。

**参数名称**可以是字母、数字、下划线的任何组合序列。

**参数值**是变量存储的信息片段。参数值在 `zsh` 中可以是以下类型：字符串、整数 或者数组。

- **赋值**

最简单的赋值字符串或者数组的方式如下：

> name=value

赋值一个数组也是类似的：

> name=(value1 value2 value3 ... valueN)

要删除一个参数，只需要：

> unset PARAMETER_NAME

- **作用域**

`Shell` 函数为 `shell` 参数的作用域。这和一些编程语言类似。

当你读取或者设置一个变量时，`zsh` 查找**当前函数**来看变量是否存在。如果不存在，它会查找下一层的函数，一直下去，直到全局变量。因此，如果你为不存在的变量赋值，变量将在最外层的作用域中创建。（导出新的参数也有这个效果）

如果一个变量 X 超出范围，它将会被删除。（就像c语言一样）如果变量X存在于外部作用域中，它将会被使用。

- **位置参数**

位置参数包括当前运行的 `shell` 或 `shell` 脚本的参数。参数以数字 `0` 开头，并一直增加。在`zsh`中，它们可以**超过**`9`，（所以，`$11`是第十一个参数），`$0` 通常包含当前运行脚本或者`shell`的名称。

有三个数组包含所有的位置参数：`@`，`*`  和  `argv`。（它们之间有微小的区别，请查看手册）

位置参数可以由三种方式配置：

- 在`shell`调用时
- 使用内建函数 `set`
- 直接赋值

#### 数组参数

数组参数只是 `zsh` 中的一个包含多个条目列表的变量。

两种最简单的给数组参数赋值的方式为：

> array_name=(value1 value2 ... valueN)
>
> set -A array-name value1 value2 ... valueN

**单个元素下标**

下标用于从数组中选择一个或多个目标。`zsh` 的数组下标机制非常强大，可以说比很多编程语言都优秀。

简单的形式如下：

> some_array[expr]

这使用算数扩展将 **`expr`** 计算为整数`n。`**`n`**用来返回数组的第**`n`**个元素。

如果 `n` 为**负数**，则从数组的**最后**计算第 `n` 个元素。例如 **`ARGV[-2]`** 将返回 `ARGV` 的倒数第二个元素。

两个特殊的下标，`@` 和 `*` 返回数组的**所有**元素。

**获取多个连续元素**

下面的形式用来获取多个连续的元素：

> some_array[expr1, expr2]

这将返回数组 `some_array` 中由 `expr1` 至 `expr2` 的元素。同时，表达式的值应该是整数，负数的用法和上面一样。

实例：

```shell
  > friends=(c_hong bongus hizatch sh_izzo sh_long mufastaf)
  > echo $friends
  c_hong bongus hizatch sh_izzo sh_long mufastaf
  > echo $friends[2,-1]
  bongus hizatch sh_izzo sh_long mufastaf
  > echo $friends[-4,-2]
  hizatch sh_izzo sh_long
  > echo $friends[-4,3]
  hizatch
  > echo $friends[5,-4]
```

下标可以包含在大括号内的变量名称中。

> ${friends[2,5]} 
>
> 数组语法注释：
>
> 数组元素从1开始编号。 如果想从0开始编号（这样更直观一些），可以打开选项 KSH_ARRAYS。
>
> （注意：打开这个选项还有其他一些影响，具体请看手册）
>
> “@” 和 “*” 有一个细微的差别。
>
> > $meat[@] 返回：`"$meat[1]" "$meat[2]" ... "$meat[n]"` 
> >
> > $meat[*] 返回：`"$meat[1] $meat[2] ... $meat[n]"` 
>
> 如果设置了`KSH_ARRAYS`选项，下标**必须**包含在大括号内的数组名称中。
>
> 注意美元符号**不**包括在命令内。

**替换部分数组**

如果下标在赋值语句的**左侧**，则整个下标表示的范围都将由右侧的表达式替换。

实例：

```shell
  > veg=(lettuce carrot celery tomato onion)
  > echo $veg
  lettuce carrot celery tomato onion
  > veg[4]=(pepper radish)
  > echo $veg
  lettuce carrot celery pepper radish onion
```

**下标字符串**

这部分并非完全和数组相关，但是这很有用。

下标也可以在非数组值上使用。当它被使用时，下标指定这个变量的子字符串。（与数组中的元素列表相反）

实例：

```shell
  > pain=cluster
  > echo $pain
  cluster
  > echo $pain[3]
  u
  > echo $pain[2,5]
  lust
  > echo $pain[-6,7]
  luster
  > unset pain
```



#### 下标标志

如果你觉得下标还不够强大，`zsh` 提供的一些标志来修改选择数组或字符串一部分的行为。

**语法**

每个标志都是一个字符。一些标志需要参数；它们的形式是 `F:arg:`，`F`是一个单字母标志，`arg` 是标志的参数。

你要指定的一个或多个标志**必须**包含在括号内。它可以再方括号后立即出现。如果范围被指定了（`2`个由逗号分隔的下标），你可以在逗号后立即使用另一个标志。

> ${VAR[(X)expr1,(Y)expr2] 

其中`X`是一组标志，`Y`可以是另一组标志。

**各种标志**

- 标志：`w`

告诉`zsh`用**单词**指定一个标量，而不是单个字符。

实例：

```shell
  > VAR="this is a big long sentence"
  > echo $VAR[(w)5]
  long
  > echo $VAR[2,(w)4]
  his is a big
  > echo $VAR[(w)2,15]
  is a big l
  > echo $VAR[(w)5,17]
  lon
  > echo $VAR[(w)-3,-4]
  big long sente
  > echo $VAR[(w)-5,(w)-2]
  is a big long
```

- 标志：`s:string:`(和`w`一起使用)

如果你想使用除了空格以外的字符来分隔标量，可以使用`s`指定。

实例：

```shell
  > AR="this/is/a/long/sentence"
  > echo $AR[(ws:/:)4]
  long
```

- 标志`p`

有时候你需要分隔奇怪的或不可打印的字符。如果你在`s:string:`之前加入`p`，你可以使用所有的`print `转义序列。(`print`是`zsh`内建命令)。

用一个复杂的例子来详细说明：

```shell
  > # The < BEEP > marks where the computer beeps
  > AR="this\C-gis a long sentence"
  > echo $AR
  this\C-gis a long sentence
  > print $AR
  this< BEEP >is a long sentence
  > # Don't forget to escape the backslash for the control character!
  > echo $AR[(wps:\\C-g:)1]
  this
```

- 标志：`f`

使用`f`标志如果你想以行为单位指定下标。这是`(wps: \n:)`的缩写。

实例：

```shell
  > AR=`head /etc/passwd`
  > echo $AR[(f)2]
  sumikeh:x:0:3::/:/usr/bin/zsh
```

- 标志：`r`

这是一个有趣并且有用的标志。当你指定标志`r`时，`zsh`会将下标表达式作为一个`pattern`而不是一个整数。

它返回的东西取决于你指定的变量类型。

| 变量类型 | 返回结果                          |
| -------- | --------------------------------- |
| 一个数组 | 匹配`pattern`的第一个**元素**     |
| 一个标量 | 匹配`pattern`的第一个**子字符串** |

一个带有`w`标志的标量会返回匹配的第一个**单词**。

- 标志：`R`

这个标志和`r`很像，但是它返回的是**最后一个**匹配的条目。

- 标志：`i`

这个标志和`r`相似，不过返回的是**第一个**匹配条目的**索引**。

- 标志：`I`

这个标志和`i`相似，不过返回的是**最后一个**匹配条目的**索引**。

- 标志：`n:expr:`

`n`是标志`r`, `R`, `i`和`I`中的一个。

`expr`是一个整数。（或者一个表达式，它的值是整数！）我们称这个值为`x`，`zsh`会返回第`x`个匹配的值（或倒数第`x`个）。

#### 参数扩展

**什么是参数扩展？**

它比听起来简单的多。意思是为了从一些变量中获取值，你只要在前面加上`$`。也就是，`$PWD`代表变量`PWD`的值。

重要的是，你要知道还有更多有用的方法来代替变量的值。我们在下面回顾`zsh`的扩展机制。

接下来我们会讨论一些可以用来改变`zsh`扩展变量的标志。

**参数扩展的形式**

---

形式：`${VAR}`

这实际上是`$VAR`的替代形式。`VAR`的值会被替代，如果存在的话。

如果`VAR`后面跟着一个你并不想作为名字的一部分的字母，则**必须**使用大括号。

实例：

```shell
  lyric[127]: NAME=Larry
  lyric[128]: echo $NAMED
  
  lyric[129]: echo ${NAME}D
  LarryD
```

---

形式：`${+VAR} `

如果变量`VAR`存在，则返回`1`；否则，返回`0`。

---

形式：`${VAR:-word} `

如果变量`VAR`存在并且非空，像往常一样显示。否则，显示`word`。

---

形式：`${VAR:=word} `

如果变量`VAR`未指定或为空，则将其指定为`word`，否则，返回`word`。

---

形式：`${VAR:?word} `

如果变量`VAR`存在并且非空，则返回它的值。否则，打印`word`并退出当前命令或脚本。

---

形式：`${VAR:+word} `

如果`VAR`存在并非空，则返回`word`。否则，什么都不返回。

---

**注意**：上面的表达式都带有一个冒号。如果删除了冒号，`zsh`只会检查变量是否存在，并**不在意**它是否为空。

---

形式：`${VAR::=word} `

设置`VAR`为`word`。然后返回这个参数的值。这和`:=`相似，不过它**强制**赋值。

---

形式：`${name#pattern} ` `${name##pattern} `

如果`pattern`匹配`name`的开始，返回未匹配的部分。如果没有匹配，直接返回`name`。

第一种形式为最小匹配。（非贪婪模式）第二种形式为贪婪模式，最大的匹配模式是首选。（贪婪模式）

---

形式：`${name%pattern} ` `${name%%pattern} `

和上面的形式相似，不过匹配的是**末端**。

---

形式：`${name:#pattern} `

如果模式`pattern`匹配`name`，则代表空字符串。否则，显示`name`。

如果`name`是一个数组，匹配的数组元素被删除。使用`M`标志删除不匹配的元素。

如果`name`是一个数组，则在数组的每个元素分别执行如果替换未被引用，使用标志`@`或`name[@]`。

---

形式：`${#sub} `

`sub`可以是上面的任何代替。但是会返回结果的字符长度，而不是结果本身。如果`sub`是一个数组表达式，则代替结果的元素数目。

### 文件名生成

**文件名生成**是当你在UNIX SHELL中指定一个`pattern`，它会将`pattern`替换为与模式匹配的所有文件的名称。下面是`pattern`一些简单的例子：

```shell
rm *
ls -l get_buf.?
```

另一个常用的术语叫做**通配符扩展**。

`Zsh` 提供了一个非常强大的文件名生成 - 它可以完成所有UNIX shell 可以做的事。要关闭文件名生成，关闭选项`GLOB`。（`unsetopt GLOB`）

**模式由什么构成？**

如果`zsh`在单词中看到以下符号，`zsh`会将这个单词当做一个文件名生成器的`pattern`。

> \* ( | < [ ? 

如果选项`EXTENDED_GLOD`打开，`zsh`还会识别以下内容：

> ^ # 

如果一个或多个文件符合这个`pattern`，`zsh`用匹配文件名的排序列表替换该单词。如果没有匹配，你可以配置`zsh`的行为：

| 配置                | 行为             |
| ------------------- | ---------------- |
| 默认                | 显示错误信息     |
| 设置`NULL_GLOD`选项 | 从命令行删除单词 |
| 设置`NOMATCH`选项   | 保留单词不变     |

**递归匹配**

`Zsh`提供了一种递归匹配的非常有用的方法。使用`**/`,然后它会递归搜索所有的目录。使用`***/`如果你想让`zsh`搜索符号链接。

例如，要在一个目录和所有子目录查找所有的`.c`, `.h`和`.o`文件，输入以下内容：

```shell
  lyric > print -l /usr/local/src/**/*.[cho]
  ...
  /usr/local/src/fvwm-2.2/modules/FvwmWinList/Mallocs.c
  /usr/local/src/fvwm-2.2/modules/FvwmWinList/Mallocs.h
  /usr/local/src/fvwm-2.2/utils/xpmroot.c
  /usr/local/src/mutt-0.95.4/_regex.h
  /usr/local/src/mutt-0.95.4/acconfig.h
```

**注意：匹配`/`和`.`**

当你使用`.`和`/`时，有一些特殊的规则。

1. `/`必须被明确的匹配。

如果你想匹配一个目录，你必须明确的将`/`写入`pattern`。

2. `.`必须明确的在一个`pattern`的**开始**或者跟在`/`**后面**。

以`.`开始的隐藏文件不会匹配通配符**除非**你在开始或者`/`后面加入`.`。

3. 没有`pattern`可以匹配`.`或者`..`。即当前目录和上层目录。

`.`和`..`永远不会再通配中出现。

如果设置了选项`GLOB_DOTS`，则规则2不适用。

[相关选项](https://www-s.acm.illinois.edu/workshops/zsh/related/file_gen.html)

#### 修饰符

修饰符是一个强大的机制，可以让你更改参数、文件名、和历史命令扩展返回的结果。

以下是`zsh-3.1.5`提供的修饰符列表。

---

**注意：**

带有`<H>`标记只适合历史扩展。

带有`<FP>`标记只适合文件名和参数扩展。

| 标记           | 功能                                            |
| -------------- | ----------------------------------------------- |
| `h`            | 删除尾部路径名，保留头部                        |
| `r`            | 删除形式为`.xxx`的后缀，留下基础名称            |
| `e`            | 删除后缀以外的所有内容                          |
| `t`            | 删除所有主要的路径名，留下尾部                  |
| `p` <H>        | 打印新的命令但是不执行它                        |
| `q` <H>        | 引用替代词，避免进一步替代                      |
| `x` <H>        | 像`q`一样但是在每个空白处插入单词               |
| `l`            | 将单词全部转为小写                              |
| `u`            | 将单词全部转为大写                              |
| `f` <FP>       | 重复修饰符，知道单词不再改变                    |
| `F:expr:` <FP> | 像f一样不过重复`expr`次                         |
| `w` <FP>       | 让修饰符，对字符串中的每个单词生效              |
| `W:sep:` <FP>  | 像w一样，但是单词由`sep`分隔                    |
| `s/l/r[/]`     | 将`r`用`l`代替。如果跟着一个`g`，则只匹配第一个 |
| `&`            | 重复之前的替换，像`s`一样，可以使用`g`          |

`s/l/r/`替换条件如下：

- 左侧**不是**正则表达，而是字符串
- 任何字符都可以用作分隔符代替`/`
- 反斜杠`\`引用分隔符
- 字符`&`在右侧`r`中，被左侧`l`替换
- `&`可以被反斜杠引用
- 一个空的`l`使用前一个来自`l`的字符串或来自上下文扫描`!?s`中的`s`
- 如果`r`紧跟着换行符，你可以省略最右边的分隔符
- 最右边的`?`在上下文扫描中可以省略
- 注意，所有的扩展中最后的`l`和`r`都会保留相同记录

#### 文件名生成：操作符和限定符

---

**操作符**

以下字符串用来匹配文件名：

`*`：匹配任何字符串，包括空字符串。
`?`：匹配任意一个字符
`[...]`：匹配任何附加字符

- 字符范围可以由`-`分隔的两个字符限定
- `]`和`-`可以作为列表的第一个字符匹配
- 有一些特殊的字符类可以由格式`[:CLASS:]`指定。请注意，方括号用于指定一系列字符。
- 下面是字符类的列表：
  - `[:alnum:]`：字母和数字组合
  - `[:alpha:]`：字母
  - `[:blank:]`：空格或制表符
  - `[:cntrl:]`：控制字符
  - `[:digit:]`：十进制数字
  - `[:graph:]`：除空格外可打印字符
  - `[:lower:]`：小写字母
  - `[:print:]`：可打印字符
  - `[:punct:]`：除了字母数字和空格的可打印字符
  - `[:space:]`：空白字符
  - `[:upper:]`：大写字符
  - `[:xdigit:]`：十六进制数字
  - 以上由`os`提供。

`[^...]`：类似于`[...]`，但是匹配所有字符。
`[!...]`：和`[^...]`相同
`(...)`：匹配封闭的`pattern`，用于分组

`x|y`：匹配`x`或者`y`。优先权最低，必须用于`(...)`内，避免作为管道符。

`^x`：（需要打开`EXTENDED_GLOB`）匹配除了`x`的所有字符。优先级高于`/`，例如`^foo|bar`会在除了`./foo`以外的文件夹寻找`bar`文件。

`x~y`：（需要打开`EXTENDED_GLOB`）返回匹配`x`不匹配`y`的结果。优先权低于除了`|`以外的所有符号。所以，`*/*~foo/bar`会搜索`.`目录下的所有文件除了`foo/bar`。可以从左向右排除多个，例如`foo~bar~baz`。

`x#`：（需要打开`EXTENDED_GLOB`）匹配出现0次或多次`x`。高优先权。`12#`等于`1(2#)`，而不是`(12)#`。

`x##`：（需要打开`EXTENDED_GLOB`）匹配出现0次或多次`x`。`12##`等于`1(2##)`，而不是`(12)##`。

---

**限定符**

有时候你不想要匹配到的**每一个**结果。例如，可能你想要忽略目录。`zsh`提供许多限定符来限制模式匹配的文件名。你应该用括号包含这个限定符。

| 限定符      | 代表                                                |
| ----------- | --------------------------------------------------- |
| `/`         | 目录                                                |
| `.`         | 纯文件                                              |
| `@`         | 符号链接文件                                        |
| `=`         | 端口                                                |
| `p`         | 命名的管道                                          |
| `*`         | 可执行纯文件                                        |
| `%`         | 设备文件                                            |
| `%b`        | 块特殊文件                                          |
| `%c`        | 字符特殊文件                                        |
| `r`         | 可读文件                                            |
| `w`         | 可写文件                                            |
| `x`         | 可执行文件                                          |
| `A`         | 组可读文件                                          |
| `I`         | 组可写文件                                          |
| `E`         | 组可执行文件                                        |
| `R`         | 全部可读文件                                        |
| `W`         | 全部可写文件                                        |
| `X`         | 全部可执行文件                                      |
| `s`         | 设置 `uid`文件                                      |
| `S`         | 设置`gid`文件                                       |
| `t`         | 带有粘性位的文件                                    |
| `ddev`      | 在`dev`设备上的文件                                 |
| `l[-`       | `+]ct`                                              |
| `U`         | 属于`UID`的文件                                     |
| `G`         | 属于`GID`的文件                                     |
| `uid`       | 如果是数字，则为数字，否则为`u:name`或`u[name]`等等 |
| `gid`       | 和`uid`类似                                         |
| `a[Mwhm][-` | `+]n`                                               |
| `m[Mwhm][-` | `+]n`                                               |
| `c[Mwhm][-` | `+]n`                                               |
| `L[+`       | `-]n`                                               |
| `^`         | 否定后面所有词                                      |
| `-`         | 生效于符号链接和它们指向的文件                      |
| `M`         | 为当前模式设置`MARK_DIRS`选项                       |
| `T`         | 为当前设置`LIST_TYPES`选项                          |
| `N`         | 为当前模式设置`NULL_GLOB`选项                       |
| `D`         | 为当前模式设置`GLOB_DOTS`选项                       |
| `n`         | 设置`NUMERIC_GLOB_SORT`选项                         |

## 可编程补全

注意：

在继续之前，请牢记`zshcompctl`手册页。补全语法偶尔有点棘手。

---

补全是指`zsh`能够补全你的命令。它有很多形式。默认情况下，`<TAB>`键绑定到补全命令。

实例：

```shell
  > ls
  array.NOTES  array.c      array.h      launch.c
  > wc -l arr< TAB >
```

点击`<TAB>`键，`zsh`将采用字符串`arr`，并解析为`arr`开头的文件名。

由于存在多个文件，你可以让`zsh`显示一个选项菜单，或者通过多次按`<TAB>`键来循环遍历每个选项。

这仅仅是**开始**。文件名是**默认**补全的条目。在`zsh`中，**任何**东西都可以被补全，包括：

- 文件名
- 文件系统目录
- 内建命令
- 外部命令
- 别名
- `shell`函数
- 保留字
- 全局别名
- 禁用的哈希表元素
- `shell`选项
- `shell`参数名
- 环境变量
- 命名目录
- 绑定按键
- 运行的任务
- 暂停的任务
- 用户名
- 所有你可以想像的东西，你可以自己简单的编程

### 开始补全

有许多方式可以在命令行指定补全。我们会讨论最主要的一种方式，这可以让你很舒服的补全。当你准备好应付更多时，查看手册页面。

我们主要讨论的语法形式基本上为：

> compctl [ -CDT ] options [command ...] 

- 补全定义以命令行上的命令`compctl`开头。
-  补全定义以你要补全的命令结尾。
- `options`列表指定所有你要补全的条目类型。（变量，选项，文件名，任务等）

你可以通过键入`compctl`查看当前所有定义。

**一些例子：**

我们来看一个例子。你有一些你经常登录的主机。许多名字很长很麻烦。你想要仅仅输入一些字符然后按`<TAB>`键来补全你的主机名。第一，我们将我们想要补全的主机名放入一个文件，每个一行，并命名为`comp_login_cmds`：

```shell
  > cat ./zsh/comp_login_cmds
  www.nebcorp.com
  www.acm.uiuc.edu
  schrof.net
  www.meat.net
  www.zsh.org
```

现在用于命令行。让我们使用一些很酷的技巧。我们会从完整的命令开始，然后分解它：

```shell
compctl -k "( ` < ./zsh/comp_login_cmds `)" telnet rlogin rsh ssh
```

现在我们看一下上面的命令：

- `comptctl`开始这个定义
- `telnet rsh rlogin ssh`是使补全起作用的命令。
- `-k`表示要补全的条目来自一个数组。使用`-k`，可以是数组的名称，也可以是双引号内的实际定义。
- 反引号`(``)`在`zsh`中运行一条命令，代替命令行的输出命令。
- 在`zsh`中，没有命令的左箭头`<`（输入重定向）在其参数上运行`cat`。因此，上面运行

```shell
cat ./zsh/comp_login_cmds 
```

并将输入打印在命令行中。

假设我们有一些主机名在文件中，现在命令行内部看起来像这样：

```shell
compctl -k "( www.nebcorp.com www.acm.uiuc.edu schrof.net www.meat.net www.zsh.org)" telnet rlogin rsh ssh
```

现在你可以输入：

```shell
> ssh www.< TAB >
```

然后`zsh`会想你展示所有以`www.`开头的条目。如果你输入：

```shell
> ssh www.a< TAB >
```

`zsh`会展示一个以`www.a`开头的条目，因此就是`www.acm.uiuc.edu`。

### 更多实例

例如：

```shell
compctl -o setopt unsetopt
```

允许你在命令`setopt`和`unsetopt`后补全所有`shell`选项。

---

例如：

```shell
compctl -j -P "%" kill
```

允许你为`kill`命令补全。`-j`补全正在运行的命令，`-P arg`指定一个前缀到补全结果。

## 额外功能

### 限制模式

有时候，我们希望严格限制UNIX账户的访问权限和特权。一旦有人想在`linux`上为他的朋友建立一个来宾账户。但是，所有者想要阻止用户窥探系统并预先禁止任何恶意活动。`zsh`通过限制模式提供了这个功能。

**限制模式的好处**

当`zsh`运行在限制模式时，用户不能够：

- 通过`set +r`或者`unsetopt RESTRICTED`关闭限制模式
- 指定一个**任何**地方包含`/`的命令名字
- 通过`cd`命令改变目录
- 使用`hash`指定命令路径名
- 使用`exec`内建命令将`shell`替换为另一个
- 将输出重定向到文件
- 使用明确给定的包含`/`的路径名指定要被加载的模块
- 使用`jobs -Z`来重写`shell`进程的参数和环境空间
- 使用`ARGVO`参数为外部命令重写`argv[0]`
- 修改或关闭一下选项：`PATH`, `MODULE_PATH`, `SHELL`, `HISTFILE`, `HISTSIZE`, `GID`, `EGID`, `UID`, `EUID`, `USERNAME`, `LD_LIBRARY_PATH`, `LD_AOUT_LIBRARY_PATH`, `LD_PRELOAD`, `LD_AOUT_PRELOAD`

上面这些限制并不能让一个账户“安全”。你应该为限制`shell`谨慎的配置初始启动配置文件。

- 你应该在初始配置文件中设置`PATH`来制定一个安全命令文件夹供用户使用
- 各种`zsh`内建命令可以在初始配置中关闭：

> disable COMMAND

`COMMAND`是要关闭的内建命令。

**打开限制模式**

有三种方式可以打开限制模式。前两个在启动时，而最后一个可以是任何时候。

1. 将`-r`命令选项用于`zsh`。
2. 以`r`开头的命令调用`zsh`。

一个简单的方法是建立一个指向`zsh`的软链接称为`rzsh`：

```shell
  lyric[251]: ln -s ./zsh rzsh
  lyric[252]: ./rzsh
  lyric[1]: cd
  cd: restricted
  zsh: exit 1
  lyric[2]:
```

注意你仍然可以模拟其他`shell`。在`r`被删除后，下一个字母用于确定仿真。例如，`rksh`会让`zsh`模拟`ksh`，并运行在限制模式。

3. 打开选项`RESTRICTED`。

### 模拟其他`shell`

`zsh`可以模拟`sh`, `ksh`或者`csh`。（`csh`并不是完全模拟）在`sh`和`ksh`模拟中表现出色。

你可以通过运行`emulate some_shell`模拟其他的`shell`。如果你加上`-R`标志，选项会被重置为它们的默认值。

你也可以创建一个名称为`csh`, `ksh` 或 `sh`的链接指向`zsh`。`zsh`会注意到它被不同的名称调用，并尽其所能表现的像你指定的`shell`。

## ZSH更多的信息

**获取 zsh**

`zsh`的主网站为：

Ftp：`ftp://ftp.zsh.org/pub/zsh`

Web：`http://www.zsh.org/pub/zsh`

本地UIUC FTP同样可用：

> ```
> ftp://uiarchive.cso.uiuc.edu/pub/packages/shells/zsh
> ```

**文档**

`zsh`问答，手册，文档，教程，配置文件实例和其他信息可以在以下网址找到：

> http://www.zsh.org/

源代码还附带了一组手册页：

> 由于`zsh`有许多特色，手册被分为几个部分：
>
> | 命令        | 描述                     |
> | ----------- | ------------------------ |
> | zsh         | zsh 总览                 |
> | zshmisc     | 其他手册不包含的所有部分 |
> | zshexpn     | zsh 命令和参数扩展       |
> | zshzle      | zsh 命令行编辑           |
> | zshparam    | zsh 参数                 |
> | zshoptions  | zsh 选项                 |
> | zshbuiltins | zsh 内建函数             |
> | zshcompctl  | zsh 补全控制             |
> | zshmodules  | zsh 可加载模块           |
> | zshall      | 包含以上所有的元页面     |

例如要了解有关`zsh`参数的信息，请输入`man zshparam`。

**邮箱列表**

*略*

## 要记住的事情

- `shell`并不容易学习。这需要时间。尽可能的练习和尝试。查看其他人的配置文件。多看多学……
- `shell`圣战不值得。做一个小调查，选择一个`shell`，让它为你工作。
- `zsh`的手册页总会是对的。作者在提供绝对准确信息这方面很出色。
- 不要感到沮丧。`zsh`有许多小的语法怪癖。第一次尝试很难得到你想要的。`zsh`中很酷的东西本来就是有用的，虽然看起来不漂亮。经常使用手册页，并密切关注语法注释。
- 你可以带马去喝水，但是你不能用水桶给它头上一下，并期待它为此感到高兴。